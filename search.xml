<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>标定基础-XCP协议之协议层指令详解</title>
      <link href="/protocol/biao-ding-ji-chu-xcp-xie-yi-zhi-xie-yi-ceng-zhi-ling-xiang-jie/"/>
      <url>/protocol/biao-ding-ji-chu-xcp-xie-yi-zhi-xie-yi-ceng-zhi-ling-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="标准-STD-指令"><a href="#标准-STD-指令" class="headerlink" title="标准(STD)指令"></a>标准(STD)指令</h2><h3 id="必实现指令"><a href="#必实现指令" class="headerlink" title="必实现指令"></a>必实现指令</h3><h4 id="0xFF-CONNECT"><a href="#0xFF-CONNECT" class="headerlink" title="0xFF:CONNECT"></a>0xFF:CONNECT</h4><p><img src="/image/xcpcmd/CONNECT.png" alt="CONNECT"></p><p>该命令与从设备建立一个连续的、逻辑的、点到点的连接设备。在运行XCP会话期间(已连接)，此命令对任何XCP会话不没有影响任何XCP从设备的配置。<br>从设备在非连接状态时不响应任何其他命令(除了自动检测)。</p><p>Mode参数：</p><ul><li>Mode = 0x00(Normal) 主机可以与从设备启动XCP通信。</li><li>Mode = 0x01(user defined) 主机可以启动XCP通信同时告诉从机它应该进入一个特殊的(用户定义的)模式。</li></ul><p>RESSOURCE参数：</p><ul><li>CAL/PAG、DAQ、STIM、PGM = 1 表示该资源可用，反之不可用。</li></ul><p>COMM_MODE参数：</p><ul><li><p>ADDRESS_GRANULARITY_1、ADDRESS_GRANULARITY_0：</p><ul><li>00： ADDRESS_GRANULARITY=BYTE    AG=1</li><li>01： ADDRESS_GRANULARITY=WORE    AG=2</li><li>10： ADDRESS_GRANULARITY=DWORD    AG=4</li><li>11： ADDRESS_GRANULARITY=保留       AG=保留</li></ul></li><li><p>SLAVE_BLOCK_MODE参数：</p><ul><li>1：表示从机块模式可用</li><li>0：表示从机块模式不可用</li></ul></li><li><p>OPTIONAL参数：</p><ul><li>1：表示支持类型的附加信息的通信模式</li><li>0：表示不支持类型的附加信息的通信模式</li></ul></li></ul><p>MAX_CTO参数：</p><ul><li>最大CTO大小，单位为字节。</li></ul><p>MAX_DTO参数：</p><ul><li>最大DTO大小，单位为字节。</li></ul><blockquote><p>注意：MAX_CTO、MAX_CTO必须始终满足下列关系：<br>MAX_CTO mod AG = 0<br>MAX_DTO mod AG = 0<br>所有涉及从设备地址范围的长度信息都基于AG(元素)。<br>如果长度信息指的是数据流(XCP协议)，则它是基于字节。</p></blockquote><h4 id="0xFE-DISCONNECT"><a href="#0xFE-DISCONNECT" class="headerlink" title="0xFE:DISCONNECT"></a>0xFE:DISCONNECT</h4><p><img src="/image/xcpcmd/DISCONNECT.png" alt="DISCONNECT"></p><h4 id="0xFD-GET-STATUS"><a href="#0xFD-GET-STATUS" class="headerlink" title="0xFD:GET_STATUS"></a>0xFD:GET_STATUS</h4><p><img src="/image/xcpcmd/GET_STATUS.png" alt="GET_STATUS"></p><p>Session参数：</p><ul><li>STORE_CAL_REQ：STORE_CAL_REQ = 1标志表示保存校准数据到非易失性内存的挂起请求。一旦请求被满足，从设备将重置该位。从设备可以通过传输EV_STORE_CAL来指示。</li><li>STORE_DAQ_REQ：STORE_DAQ_REQ = 1标志表示保存DAQ列表设置到非易失性内存的挂起请求。一旦请求被满足，从设备将重置该位。从设备可以通过传输EV_STORE_DAQ来指示。</li><li>CLEAR_DAQ_REQ：CLEAR_DAQ_REQ = 1标志表示清除所有非易失中DAQ列表的挂起请求。所有ODT表项重置为address = 0, extension = 0, size = 0, bit_offset = FF。会话配置ID重置为0。一旦请求得到满足，从设备将重置该位。从设备可以通过发送信号EV_CLEAR_DAQ来指示。<br>如果从设备不支持所请求的模式，返回ERR_OUT_OF_RANGE。</li><li>DAQ_RUNNING=1：表示至少有一个DAQ列表已经启动并处于状态运行模式。</li><li>RESUME=1：表示从机处于RESUME模式。</li></ul><p>Protection参数：</p><ul><li>CAL/PAG：CAL/PAG = 1 表示该资源受保护需要解锁才能使用。</li><li>DAQ：DAQ = 1 表示该资源受保护需要解锁才能使用。</li><li>STIM：STIM = 1 表示该资源受保护需要解锁才能使用。</li><li>PGM：PGM = 1 表示该资源受保护需要解锁才能使用。</li></ul><blockquote><p>标准命令永远不会被保护</p></blockquote><h4 id="0xFC-SYNCH"><a href="#0xFC-SYNCH" class="headerlink" title="0xFC:SYNCH"></a>0xFC:SYNCH</h4><p><img src="/image/xcpcmd/SYNCH.png" alt="SYNCH"></p><p>该命令用于同步超时后的命令执行，SYNCH命令将始终有一个带有错误代码的否定响应ERR_CMD_SYNCH。没有其他命令使用此错误代码。</p><h3 id="可选实现指令"><a href="#可选实现指令" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xFB-GET-COMM-MODE-INFO"><a href="#0xFB-GET-COMM-MODE-INFO" class="headerlink" title="0xFB:GET_COMM_MODE_INFO"></a>0xFB:GET_COMM_MODE_INFO</h4><p><img src="/image/xcpcmd/GET_COMM_MODE_INFO.png" alt="GET_COMM_MODE_INFO"></p><p>COMM_MODE参数：</p><ul><li><p>MASTER_BLOCK_MODE参数：表示主设备的块模式是否可用。如果支持主设备块模式：</p><ul><li>则MAX_BS为允许的最大块大小作为连续命令包的数量(DOWNLOAD_NEXT或PROGRAM_NEXT)。</li><li>MIN_ST所需的最小值，是一个块的数据包从主设备传输到从设备的分离时间，单位为100微秒。</li></ul></li><li><p>INTERLEAVED_MODE参数：表示交错模式是否可用。如果存在交错模式：</p><ul><li>QUEUE_SIZE为最大数目。主站可以向从站的接收队列发送连续的命令包。</li></ul></li></ul><h4 id="0xFA-GET-ID"><a href="#0xFA-GET-ID" class="headerlink" title="0xFA:GET_ID"></a>0xFA:GET_ID</h4><p><img src="/image/xcpcmd/GET_ID.png" alt="GET_ID"></p><p>Type参数：</p><ul><li>0：ASCII文本</li><li>1：ASAM-MC2文件名，没有路径和扩展</li><li>2：ASAM-MC2文件名，有路径和扩展</li><li>3：ASAM-MC2文件所在的URL路径</li><li>4：ASAM-MC2文件上传</li><li>128-255：自定义</li></ul><p>Length参数：</p><ul><li>指定标识中的字节数。如果length为0，则请求的标识类型不可用。</li><li>数据元素是BYTE, WORD或DWORD，取决于AG。</li><li>Mode=0时，从设备将MTA (Memory Transfer Address)设置为当前地址。主设备可以使用一个或多个UPLOAD命令。</li><li>标识字符串是ASCII文本格式，它没有0结尾。</li></ul><h4 id="0xF9-SET-REQUEST"><a href="#0xF9-SET-REQUEST" class="headerlink" title="0xF9:SET_REQUEST"></a>0xF9:SET_REQUEST</h4><p><img src="/image/xcpcmd/SET_REQUEST.png" alt="SET_REQUEST"></p><p>Mode参数：</p><ul><li>STORE_CAL_REQ：标记了将校准数据保存到非易失性内存中的请求。可以通过GET_STATUS获取的STORE_CAL_REQ位，该位将被从机重置当请求已完成。从设备可以通过传输EV_STORE_CAL来指示传输。</li><li>STORE_DAQ_REQ：标记了一个保存所有DAQ列表的请求。目标是START_STOP_DAQ_LIST指令选择的非易失性内存。从设备还必须存储非易失性内存中的会话配置id。在保存时，从设备首先必须清除可能已经存在的任何DAQ列表配置。可以通过GET_STATUS获得的STORE_DAQ_REQ位，该位将被从机重置当请求已完成。从设备可以通过传输EV_STORE_DAQ来指示传输。</li><li>CLEAR_DAQ_REQ用于清除非易失性内存中的所有DAQ列表。所有ODT条目reset address = 0, extension = 0, size = 0, bit_offset = FF，会话配置ID重置为0。通过GET_STATUS获得的CLEAR_DAQ_REQ位，该位将被从机重置当请求已完成。从设备可以通过传输EV_CLEAR_DAQ来指示。<blockquote><p>如果从设备不支持所请求的模式，则返回ERR_OUT_OF_RANGE。</p></blockquote></li></ul><h4 id="0xF8-GET-SEED"><a href="#0xF8-GET-SEED" class="headerlink" title="0xF8:GET_SEED"></a>0xF8:GET_SEED</h4><p><img src="/image/xcpcmd/GET_SEED.png" alt="GET_SEED"></p><p>Mode参数：</p><ul><li>Mode=0：第一部分种子获取</li><li>Mode=1：剩余种子获取</li></ul><p>Resource参数：</p><ul><li>Mode=0：Resource=需要解锁的资源</li><li>Mode=1：Resource不关心</li></ul><p>Length参数：</p><ul><li>Mode=0：Length=主设备请求种子总长度。</li><li>Mode=1：Length=主设备请求种子剩余长度。(Length大于MAX_CTO-2是才使用该模式)</li></ul><blockquote><p>主设备必须在定义的顺序中使用GET_SEED(Mode=1)和GET_SEED(Mode= 0)。<br>如果主设备直接发送GET_SEED(Mode=1)，而不在之前使用GET_SEED(Mode=0)，从服务器返回一个ERR_SEQUENCE为负响应。</p></blockquote><p>Resource参数：</p><ul><li>请参阅GET_STATUS(资源保护状态)命令。</li></ul><blockquote><p>一个GET_SEED命令只能请求一个资源。如果不止一个资源必须被解锁，(GET_SEED+UNLOCK)序列必须执行多次。主服务器不请求任何资源或请求多个资源，从机将响应ERR_OUT_OF_RANGE。</p></blockquote><h4 id="0xF7-UNLOCK"><a href="#0xF7-UNLOCK" class="headerlink" title="0xF7:UNLOCK"></a>0xF7:UNLOCK</h4><p><img src="/image/xcpcmd/UNLOCK.png" alt="UNLOCK"></p><p>使用种子算的密钥来解锁从机的安全保护。种子由之前的GET_SEED序列获得。<br>Length参数：</p><ul><li>表示剩余密钥字节数。</li><li>主机必须在定义的序列中使用UNLOCK和GET_SEED。如果之前只有一个GET_SEED，主服务器只能发送一个UNLOCK序列。</li><li>如果密钥的总长度大于MAX_CTO-2，主服务器必须发送剩余的密钥字节，连续的UNLOCK命令包含剩余的键的长度。</li></ul><blockquote><p>如果主服务器不尊重这个序列，从服务器返回ERR_SEQUENCE为负响应。<br>完成UNLOCK序列后检查密钥。如果钥匙不被接受，将返回ERR_ACCESS_LOCKED。从设备将转到断开连接状态。使用正确的密钥重复UNLOCK序列将会有一个积极的响应，没有其他影响。</p></blockquote><p>Example:<br>MAX_CTO = 8 bytes (CAN)<br>Seed = 11 22 33 44<br>TotalLengthOf(seed) = 4 bytes<br>Key = 43 21<br>TotalLengthOf(key) = 2 bytes </p><img src="/image/xcpcmd/UNLOCK_Example.png" alt="解锁例子" style="zoom:50%;" /><p>MAX_CTO = 8 bytes (CAN)<br>Seed = 99 88 77 66 55 44 33 22 11 00 11 22 33 44 55 66 77 88 99<br>TotalLengthOf(seed) = 19 bytes<br>Key = 98 76 54 32 10 01 23 45 67 89<br>TotalLengthOf(key) = 10 bytes </p><img src="/image/xcpcmd/UNLOCK_Example2.png" alt="解锁例子" style="zoom:50%;" /><h4 id="0xF6-SET-MTA"><a href="#0xF6-SET-MTA" class="headerlink" title="0xF6:SET_MTA"></a>0xF6:SET_MTA</h4><p><img src="/image/xcpcmd/SET_MTA.png" alt="SET_MTA"></p><p>这个命令将内存初始化一个指针(32位地址+ 8位扩展)转移指令。</p><blockquote><p>MTA用于命令BUILD_CHECKSUM, UPLOAD, DOWNLOAD，DOWNLOAD_MAX, MODIFY_BITS, PROGRAM_CLEAR，PROGRAM和PROGRAM_MAX。</p></blockquote><h4 id="0xF5-UPLOAD"><a href="#0xF5-UPLOAD" class="headerlink" title="0xF5:UPLOAD"></a>0xF5:UPLOAD</h4><p><img src="/image/xcpcmd/UPLOAD.png" alt="UPLOAD"></p><p>从当前MTA开始，将返回指定长度的数据块。MTA将按给定的数据元素数量后递增。</p><ul><li>根据AG的不同，必须使用1、2或3个对齐字节来满足对齐要求。</li><li>元素是BYTE、WORD或DWORD，取决于AG。</li></ul><p>如果从机不支持块传输模式</p><ul><li>则所有上传的数据都以单个响应包方式传输，因此请求中的数据元素数量参数必须在[1..MAX_CTO-1]范围内。</li><li>如果数据元素个数大于MAX_CTO-1，返回ERR_OUT_OF_RANGE。</li></ul><p>如果支持块传输方式，</p><ul><li>则上传的数据在多个响应中传输在同一个请求包上。</li><li>对于master，不允许有任何限制最大块大小。因此数据元素的数量(n)可以在此范围内(1 . . 255)</li><li>从设备将发送(n*AG / (MAX_CTO-1)) +1个响应报文。响应包之间的分离时间取决于从设备实现。</li></ul><p>Examples:<br>MAX_CTO=8<br>AG=1 </p><img src="/image/xcpcmd/UPLOAD_Examples.png" alt="UPLOAD_Examples" style="zoom:50%;" /><h4 id="0xF4-SHORT-UPLOAD"><a href="#0xF4-SHORT-UPLOAD" class="headerlink" title="0xF4:SHORT_UPLOAD"></a>0xF4:SHORT_UPLOAD</h4><p><img src="/image/xcpcmd/SHORT_UPLOAD.png" alt="SHORT_UPLOAD"></p><p>将返回指定长度的数据块，从Address开始。MTA指针为设置为上传数据块后面的第一个数据字节。错误处理和响应结构与UPLOAD命令相同。</p><blockquote><p>元素是字节。WORD或DWORD，取决于AG。<br>此命令不支持块传输，且不能在块传输序列中使用。</p></blockquote><h4 id="0xF3-BUILD-CHECKSUM"><a href="#0xF3-BUILD-CHECKSUM" class="headerlink" title="0xF3:BUILD_CHECKSUM"></a>0xF3:BUILD_CHECKSUM</h4><p><img src="/image/xcpcmd/BUILD_CHECKSUM.png" alt="BUILD_CHECKSUM"></p><p>返回由MTA和定义的内存块大小的计算校验和结果。MTA将按大小后增量。</p><p>Type参数：</p><ul><li>0x01:  XCP_ADD_11 将BYTE添加到BYTE校验和中，忽略溢出</li><li>0x02:  XCP_ADD_12 将BYTE添加到WORD校验和中，忽略溢出</li><li>0x03:  XCP_ADD_14 将BYTE添加到DWORD校验和中，忽略溢出</li><li>0x04:  XCP_ADD_22 将WORD添加到WORD校验和中，忽略溢出，块大小必须对2取模</li><li>0x05:  XCP_ADD_24 将WORD添加到DWORD校验和中，忽略溢出，块大小必须对2取模</li><li>0x06:  XCP_ADD_44 将DWORD添加到DWORD校验和中，忽略溢出，块大小必须对4取模</li><li>0x07:  XCP_CRC_16  参见CRC错误检测算法</li><li>0x08:  XCP_CRC_16_CITT 参见CRC错误检测算法</li><li>0x09:  XCP_CRC_32 参见CRC错误检测算法</li><li>0xFF:  XCP_USER_DEFINED 用户自定义算法，在外部计算函数</li></ul><blockquote><p>不管校验和类型是什么，结果总是以DWORD形式给出。<br>使用校验和类型XCP_USER_DEFINED时，从设备可以指示主设备为了计算校验和，必须使用在外部计算函数(例如win32 DLL, UNIX共享目标文件)，对象获取的名称在此从机的外部函数文件中。</p></blockquote><p>如果块大小超过允许的最大值，则返回ERR_OUT_OF_RANGE。最大块大小将在校验和字段中返回。</p><p>CRC算法：</p><p><img src="/image/xcpcmd/CRC.png" alt="CRC"></p><h4 id="0xF2-TRANSPORT-LAYER-CMD"><a href="#0xF2-TRANSPORT-LAYER-CMD" class="headerlink" title="0xF2:TRANSPORT_LAYER_CMD"></a>0xF2:TRANSPORT_LAYER_CMD</h4><p><img src="/image/xcpcmd/TRANSPORT_LAYER_CMD.png" alt="TRANSPORT_LAYER_CMD"></p><p>该命令在传输层规范中定义。它用于执行传输层特定的动作。</p><h4 id="0xF1-USER-CMD"><a href="#0xF1-USER-CMD" class="headerlink" title="0xF1:USER_CMD"></a>0xF1:USER_CMD</h4><p><img src="/image/xcpcmd/USER_CMD.png" alt="USER_CMD"></p><p>该命令由用户自定义。它不是必须被用来实现其他功能服务。</p><h2 id="标定-CAL-指令"><a href="#标定-CAL-指令" class="headerlink" title="标定(CAL)指令"></a>标定(CAL)指令</h2><h3 id="必实现指令-1"><a href="#必实现指令-1" class="headerlink" title="必实现指令"></a>必实现指令</h3><h4 id="0xF0-DOWNLOAD"><a href="#0xF0-DOWNLOAD" class="headerlink" title="0xF0:DOWNLOAD"></a>0xF0:DOWNLOAD</h4><p><img src="/image/xcpcmd/DOWNLOAD.png" alt="DOWNLOAD"></p><blockquote><p>如果AG = DWORD，则必须使用2个对齐字节以满足对齐要求。<br>元素是BYTE，WORD或DWORD取决于AG。</p></blockquote><p>CMD中包含的指定长度(大小)的数据块从MTA开始将被复制到内存，MTA将按数据数量后增加。</p><p>如果从机不支持块传输模式</p><ul><li>则下载的所有数据都是单个命令包中传输。因此，数据元素的数量参数请求中的值必须在[1..MAX_CTO-2]范围内。如果数据元素个数大于MAX_CTO-2，则返回ERR_OUT_OF_RANGE。</li></ul><p>如果从机支持块传输模式</p><ul><li>则下载的数据将分多个传输命令数据包。对于从设备，可能存在关于最大连续命令包(MAX_BS)。因此数据元素个数(n)的取值范围为[1..min(MAX_BS*(MAX_CTO-2)/AG,255)]。主设备必须连续传输(n * AG / (MAX_CTO-2)) - 1个DOWNLOAD_NEXT命令包。从设备将只回复最后DOWNLOAD_NEXT命令包。命令包之间的分离时间在CONNECT的响应中指定最大数据包数(MAX_BS, MIN_ST)。</li></ul><p>Example:<br>MAX_CTO=8</p><img src="/image/xcpcmd/DOWNLOAD_Example.png" alt="DOWNLOAD_Example" style="zoom:50%;" /><h3 id="可选实现指令-1"><a href="#可选实现指令-1" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xEF-DOWNLOAD-NEXT"><a href="#0xEF-DOWNLOAD-NEXT" class="headerlink" title="0xEF:DOWNLOAD_NEXT"></a>0xEF:DOWNLOAD_NEXT</h4><p><img src="/image/xcpcmd/DOWNLOAD_NEXT.png" alt="DOWNLOAD_NEXT"></p><blockquote><p>如果AG = DWORD，则必须使用2个对齐字节以满足对齐要求。<br>元素是BYTE，WORD或DWORD取决于AG。</p></blockquote><ul><li>该命令用于为DOWNLOAD传输连续的数据元素命令。</li><li>DOWNLOAD_NEXT命令的结构与DOWNLOAD完全相同命令。</li><li>Number包含要传输的剩余数量的数据元素。</li><li>从设备将使用此信息检测丢失的数据包。如果检测到序列错误，则将返回错误代码ERR_SEQUENCE。</li><li>如果数据元素的数量与期望值不匹配，则错误将返回ERR_SEQUENCE。回应将包含预期的数据元素数量。</li></ul><p>Example:<br>MAX_CTO=8 </p><img src="/image/xcpcmd/DOWNLOAD_NEXT_Example.png" alt="DOWNLOAD_NEXT_Example" style="zoom:50%;" /><h4 id="0xEE-DOWNLOAD-MAX"><a href="#0xEE-DOWNLOAD-MAX" class="headerlink" title="0xEE:DOWNLOAD_MAX"></a>0xEE:DOWNLOAD_MAX</h4><p><img src="/image/xcpcmd/DOWNLOAD_MAX.png" alt="DOWNLOAD_MAX"></p><blockquote><p>如果AG = WORD/DWORD，则必须使用1/3个对齐字节以满足对齐要求。<br>元素是BYTE，WORD或DWORD取决于AG。<br>此命令不支持块传输，并且不能块传输序列中使用。</p></blockquote><p>将被下载数据到内存中，从MTA开始。MTA将增加MAX_CTO / AG-1。</p><h4 id="0xED-SHORT-DOWNLOAD"><a href="#0xED-SHORT-DOWNLOAD" class="headerlink" title="0xED:SHORT_DOWNLOAD"></a>0xED:SHORT_DOWNLOAD</h4><p><img src="/image/xcpcmd/SHORT_DOWNLOAD.png" alt="SHORT_DOWNLOAD"></p><blockquote><p>元素是BYTE，WORD或DWORD取决于AG。<br>此命令不支持块传输，并且不能块传输序列中使用。<br>该命令将没有效果(没有数据字节可以传输)，如果MAX_CTO = 8</p></blockquote><p>从Address开始写入指定长度的数据块。MTA指针设置为第一个数据元素。如果是元素个数超过(MAX_CTO-8)/AG，则返回错误码ERR_OUT_OF_RANGE。</p><h4 id="0xEC-MODIFY-BITS"><a href="#0xEC-MODIFY-BITS" class="headerlink" title="0xEC:MODIFY_BITS"></a>0xEC:MODIFY_BITS</h4><p><img src="/image/xcpcmd/MODIFY_BITS.png" alt="MODIFY_BITS"></p><p>A = ( (A) &amp; ((<del>((dword)(((word)</del>MA)&lt;&lt;S))) )^((dword)(MX&lt;&lt;S)) ) </p><blockquote><p>MTA不会受到影响。</p></blockquote><p>Example:<br><img src="/image/xcpcmd/MODIFY_BITS_Example.png" alt="MODIFY_BITS_Example" style="zoom:50%;" /></p><h2 id="页面切换-PAG-指令"><a href="#页面切换-PAG-指令" class="headerlink" title="页面切换(PAG)指令"></a>页面切换(PAG)指令</h2><h3 id="必实现指令-2"><a href="#必实现指令-2" class="headerlink" title="必实现指令"></a>必实现指令</h3><h4 id="0xEB-SET-CAL-PAGE"><a href="#0xEB-SET-CAL-PAGE" class="headerlink" title="0xEB:SET_CAL_PAGE"></a>0xEB:SET_CAL_PAGE</h4><p><img src="/image/xcpcmd/SET_CAL_PAGE.png" alt="SET_CAL_PAGE"></p><p>Mode参数：</p><ul><li>ECU：给定的页面将使用从机的设备应用。</li><li>XCP：从设备XCP驱动将访问给定的页面。</li><li>ALL：逻辑段号被忽略。该命令适用于所有段。</li><li>ECU和XCP标志可以同时设置，也可以单独设置。</li><li>如果校准数据页不能设置为给定的模式，则返回ERR_MODE_NOT_VALID。</li><li>如果校准数据页不可用，则返回ERR_PAGE_NOT_VALID或ERR_SEGMENT_NOT_VALID。</li></ul><h4 id="0xEA-GET-CAL-PAGE"><a href="#0xEA-GET-CAL-PAGE" class="headerlink" title="0xEA:GET_CAL_PAGE"></a>0xEA:GET_CAL_PAGE</h4><p><img src="/image/xcpcmd/GET_CAL_PAGE.png" alt="GET_CAL_PAGE"></p><p>此命令返回当前激活的逻辑编号指定的访问模式的数据段的校准数据页。模式可以是0x01 (ECU)或0x02 (XCP)。所有其他值无效。</p><h3 id="可选实现指令-2"><a href="#可选实现指令-2" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xE9-GET-PAG-PROCESSOR-INFO"><a href="#0xE9-GET-PAG-PROCESSOR-INFO" class="headerlink" title="0xE9:GET_PAG_PROCESSOR_INFO"></a>0xE9:GET_PAG_PROCESSOR_INFO</h4><p><img src="/image/xcpcmd/GET_PAG_PROCESSOR_INFO.png" alt="GET_PAG_PROCESSOR_INFO"></p><p>PROPERTIES参数：</p><ul><li>FREEZE=1：段可以设置为冻结模式。反之不能设置为冻结模式。</li></ul><h4 id="0xE8-GET-SEGMENT-INFO"><a href="#0xE8-GET-SEGMENT-INFO" class="headerlink" title="0xE8:GET_SEGMENT_INFO"></a>0xE8:GET_SEGMENT_INFO</h4><p><img src="/image/xcpcmd/GET_SEGMENT_INFO.png" alt="GET_SEGMENT_INFO"></p><p>Mode参数：</p><ul><li>0 ：获取此段的基本地址信息</li><li>1 ：获取该分段的标准信息</li><li>2 ：获取这个SEGMENT的地址映射信息</li></ul><p>INFO参数：</p><ul><li>Mode=0：INFO=0：地址</li><li>Mode=0：INFO=1：长度</li><li>Mode=1：INFO参数不关心</li><li>Mode=2：INFO=0：源地址</li><li>Mode=2：INFO=1：目标地址</li><li>Mode=2：INFO=2：地址长度</li></ul><p>INDEX参数：</p><ul><li>Mode=0：INDEX参数不关心</li><li>Mode=1：INDEX参数不关心</li><li>Mode=2：INDEX：MAPPING_INFO所属的地址映射范围标识符</li></ul><p>GET_SEGMENT_INFO返回特定SEGMENT的信息。如果指定的SEGMENT不可用，则返回ERR_OUT_OF_RANGE。</p><p>返回指令(Mode = 0)：</p><ul><li>响应包含这个SEGMENT的地址信息。</li><li>如果SEGMENT_INFO = 0，该命令将在BASIC_INFO中返回该SEGMENT的地址。</li><li>如果SEGMENT_INFO = 1，该命令将在BASIC_INFO中返回该SEGMENT的长度。</li></ul><p>返回指令(Mode = 1)：</p><ul><li>响应包含关于这个SEGMENT的标准信息。</li><li>MAX_PAGES：表示该SEGMENT可用的page数量。</li><li>EXTENSION用于SET_MTA, SHORT_UPLOAD和SHORT_DOWNLOAD访问该SEGMENT内的PAGE时。</li><li>MAX_MAPPING：表示该SEGMENT内地址范围的数量应用地址映射。</li></ul><p>返回指令(Mode = 2)：</p><ul><li>如果Mode = 2, SEGMENT_INFO表示所请求的映射信息在MAPPING_INDEX的范围。</li><li>如果SEGMENT_INFO = 0，该命令将返回MAPPING_INFO中MAPPING_INDEX的源地址。</li><li>如果SEGMENT_INFO = 1，该命令将返回MAPPING_INFO中MAPPING_INDEX的目的地址。</li><li>如果SEGMENT_INFO = 2，该命令将返回MAPPING_INFO中MAPPING_INDEX的长度。</li></ul><h4 id="0xE7-GET-PAGE-INFO"><a href="#0xE7-GET-PAGE-INFO" class="headerlink" title="0xE7:GET_PAGE_INFO"></a>0xE7:GET_PAGE_INFO</h4><p><img src="/image/xcpcmd/GET_PAGE_INFO.png" alt="GET_PAGE_INFO"></p><p>GET_PAGE_INFO返回特定PAGE的信息。如果指定的PAGE不可用，则返回ERR_OUT_OF_RANGE。</p><p>PROPERTIES参数：</p><ul><li>ECU_ACCESS_x：<ul><li>标志表示ECU是否以及如何访问该页。</li><li>ECU_ACCESS_WITH_XCP、ECU_ACCESS_WITHOUT_XCP = 00：不允许访问ECU</li><li>ECU_ACCESS_WITH_XCP、ECU_ACCESS_WITHOUT_XCP = 01：没有XCP</li><li>ECU_ACCESS_WITH_XCP、ECU_ACCESS_WITHOUT_XCP = 10：只有XCP</li><li>ECU_ACCESS_WITH_XCP、ECU_ACCESS_WITHOUT_XCP = 11：不关心</li></ul></li><li>XCP_READ_ACCESS_x：<ul><li>标志表示XCP主机可以访问这个页面。</li><li>XCP_READ_ACCESS_WITH_ECU、XCP_READ_ACCESS_WITHOUT_ECU = 00：不允许XCP读访问。</li><li>XCP_READ_ACCESS_WITH_ECU、XCP_READ_ACCESS_WITHOUT_ECU = 01：没有ECU。</li><li>XCP_READ_ACCESS_WITH_ECU、XCP_READ_ACCESS_WITHOUT_ECU = 10：只有ECU。</li><li>XCP_READ_ACCESS_WITH_ECU、XCP_READ_ACCESS_WITHOUT_ECU = 11：不关心。</li></ul></li><li>XCP_WRITE_ACCESS_x：<ul><li>标志表示XCP主机可以写入这个页面。 </li><li>XCP_WRITE_ACCESS_WITH_ECU、XCP_WRITE_ACCESS_WITHOUT_ECU = 00：不允许XCP写访问。</li><li>XCP_WRITE_ACCESS_WITH_ECU、XCP_WRITE_ACCESS_WITHOUT_ECU = 01：没有ECU。</li><li>XCP_WRITE_ACCESS_WITH_ECU、XCP_WRITE_ACCESS_WITHOUT_ECU = 10：只有ECU。</li><li>XCP_WRITE_ACCESS_WITH_ECU、XCP_WRITE_ACCESS_WITHOUT_ECU = 11：不关心。</li></ul></li></ul><h4 id="0xE6-SET-SEGMENT-MODE"><a href="#0xE6-SET-SEGMENT-MODE" class="headerlink" title="0xE6:SET_SEGMENT_MODE"></a>0xE6:SET_SEGMENT_MODE</h4><p><img src="/image/xcpcmd/SET_SEGMENT_MODE.png" alt="SET_SEGMENT_MODE"></p><p>如果指定的SEGMENT不可用，则返回ERR_OUT_OF_RANGE。</p><p>Mode参数：</p><ul><li>FREEZE=1： 使能冻结模式。反之关闭冻结模式。</li></ul><h4 id="0xE5-GET-SEGMENT-MODE"><a href="#0xE5-GET-SEGMENT-MODE" class="headerlink" title="0xE5:GET_SEGMENT_MODE"></a>0xE5:GET_SEGMENT_MODE</h4><p><img src="/image/xcpcmd/GET_SEGMENT_MODE.png" alt="GET_SEGMENT_MODE"></p><p>如果指定的SEGMENT不可用，则返回ERR_OUT_OF_RANGE。</p><h4 id="0xE4-COPY-CAL-PAGE"><a href="#0xE4-COPY-CAL-PAGE" class="headerlink" title="0xE4:COPY_CAL_PAGE"></a>0xE4:COPY_CAL_PAGE</h4><p><img src="/image/xcpcmd/COPY_CAL_PAGE.png" alt="COPY_CAL_PAGE"></p><ul><li>该命令强制从机将一个校准页复制到另一个校准页。此命令仅在定义了多个校准页时可用。</li><li>原则上，任何段的任何页都可以复制到任何段的任何页。</li><li>如果校准数据页不能复制到给定的目的地，例如，由于目标是一个flash段，则返回ERR_WRITE_PROTECTED。</li><li>如果校准数据页不可用，则返回ERR_PAGE_NOT_VALID或ERR_SEGMENT_NOT_VALID。</li></ul><h2 id="数据采集-DAQ-指令-静态"><a href="#数据采集-DAQ-指令-静态" class="headerlink" title="数据采集(DAQ)指令(静态)"></a>数据采集(DAQ)指令(静态)</h2><h3 id="必实现指令-3"><a href="#必实现指令-3" class="headerlink" title="必实现指令"></a>必实现指令</h3><h4 id="0xE3-CLEAR-DAQ-LIST"><a href="#0xE3-CLEAR-DAQ-LIST" class="headerlink" title="0xE3:CLEAR_DAQ_LIST"></a>0xE3:CLEAR_DAQ_LIST</h4><p><img src="/image/xcpcmd/CLEAR_DAQ_LIST.png" alt="CLEAR_DAQ_LIST"></p><ul><li>此命令可用于预定义的和可配置的DAQ列表，因此范围DAQ_LIST_NUMBER是[0,1，..MAX_DAQ-1]。</li><li>如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</li><li>CLEAR_DAQ_LIST清除指定的DAQ列表。对于可配置的DAQ列表，所有ODT表项将被重置为address=0, extension=0和size=0(如果有效:bit_offset = 0xFF)。</li><li>预定义的和可配置的DAQ列表，此列表上的运行数据传输将停止，所有的DAQ列表状态被重置。</li></ul><h4 id="0xE2-SET-DAQ-PTR"><a href="#0xE2-SET-DAQ-PTR" class="headerlink" title="0xE2:SET_DAQ_PTR"></a>0xE2:SET_DAQ_PTR</h4><p><img src="/image/xcpcmd/SET_DAQ_PTR.png" alt="SET_DAQ_PTR"></p><ul><li>为WRITE_DAQ或READ_DAQ的后续操作来初始化DAQ列表指针。</li><li>如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</li><li>ODT_NUMBER是该DAQ列表中的ODT编号。</li><li>ODT_ENTRY_NUMBER是这个ODT中的ODT条目号。</li></ul><h4 id="0xE1-WRITE-DAQ"><a href="#0xE1-WRITE-DAQ" class="headerlink" title="0xE1:WRITE_DAQ"></a>0xE1:WRITE_DAQ</h4><p><img src="/image/xcpcmd/WRITE_DAQ.png" alt="WRITE_DAQ"></p><ul><li>将一个ODT条目写入由DAQ列表指针定义的DAQ列表(参见SET_DAQ_PTR)。</li><li>WRITE_DAQ仅适用于可配置DAQ列表中的元素。因此在前面的SET_DAQ_PTR中使用的DAQ_LIST_NUMBER必须在这个范围内[MIN_DAQ MIN_DAQ + 1 . . MAX_DAQ-1]。否则从机将返回一个ERR_WRITE_PROTECTED在WRITE_DAQ的负响应中。</li><li>BIT_OFFSET字段允许传输表示的数据刺激元素位的状态。e.g Bit7 -&gt; BIT_MASK = 0x80 -&gt; BIT_OFFSET = 0x07 </li><li>当BIT_OFFSET = FF时，该字段可以忽略。WRITE_DAQ适用于正常值大小用AG表示的数据元素。</li><li>如果 BIT_OFFSET 从 0x00 到 0x1F，ODTentry 描述了一个代表位状态的元素。在这种情况下，DAQ的大小元素必须总是等于GRANULARITY_ODT_ENTRY_SIZE_x。如果这个元素= 0，位的值为0。元素&gt;0，则元素的值为1。</li><li>ODT条目的大小必须满足粒度和最大值的规则。(ref GET_DAQ_RESOLUTION_INFO)。</li><li>DAQ列表指针自动递增到下一个ODT条目</li><li>写入ODT的最后一个ODT条目后，DAQ指针的值为未定义的。主机必须确保正确分配DAQ指针到下一个DAQ列表的下一个ODT。</li></ul><h4 id="0xE0-SET-DAQ-LIST-MODE"><a href="#0xE0-SET-DAQ-LIST-MODE" class="headerlink" title="0xE0:SET_DAQ_LIST_MODE"></a>0xE0:SET_DAQ_LIST_MODE</h4><p><img src="/image/xcpcmd/SET_DAQ_LIST_MODE.png" alt="SET_DAQ_LIST_MODE"></p><ul><li>此命令可用于预定义的和可配置的DAQ列表，因此范围DAQ_LIST_NUMBER是[0,1，..MAX_DAQ-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</li></ul><p>Mode参数：</p><ul><li><p>DIRECTION=0：DAQ设置为数据采集模式(Slave -&gt; Master)</p></li><li><p>DIRECTION=1：STIM设置为数据刺激模式(Master -&gt; Slave)</p></li><li><p>TIMESTAMP=1：使能时间戳，反之关闭。</p></li><li><p>PID_OFF =1：发送DTO不含PID，反之包含PID。</p></li><li><p>TIMESTAMP标志将DAQ列表设置为时间戳模式。</p></li><li><p>GET_DAQ_RESOLUTION_INFO中的TIMESTAMP_MODE中的TIMESTAMP_FIXED标志表示Master不能通过SET_DAQ_LIST_MODE关闭时间戳。如果主机仍然尝试这样做，从服务器将使用ERR_CMD_SYNTAX答复。</p></li><li><p>事件通道号指定有效确定的通用信号源数据传输时序。</p></li><li><p>DAQ列表优先级指定处理该DAQ列表时的优先级。priority = FF优先级最高。</p></li><li><p>如果ECU不支持DAQ列表优先级，则当DAQ列表优先级&gt; 0，将通过返回ERR_OUT_OF_RANGE表示。</p></li></ul><h4 id="0xDF-GET-DAQ-LIST-MODE"><a href="#0xDF-GET-DAQ-LIST-MODE" class="headerlink" title="0xDF:GET_DAQ_LIST_MODE"></a>0xDF:GET_DAQ_LIST_MODE</h4><p><img src="/image/xcpcmd/GET_DAQ_LIST_MODE.png" alt="GET_DAQ_LIST_MODE"></p><ul><li>返回指定DAQ列表的当前模式的信息。该命令可以是用于预定义的和可配置的DAQ列表，因此范围为DAQ_LIST_NUMBER是[0,1，..MAX_DAQ-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</li></ul><p>Mode参数：</p><ul><li>SELECTED=1：已选择DAQ列表。反之未选择DAQ列表。</li><li>DIRECTION=0：DAQ数据采集方式已设置。</li><li>DIRECTION=1：STIM数据刺激模式已设置。</li><li>TIMESTAMP=0：时间戳关闭，反之打开。</li><li>PID_OFF = 1：DTO的PID关闭，反之打开。</li><li>RUNNING=1：DAQ运行中，反之未运行。</li><li>RESUME=1：此DAQ列表是在RESUME模式中使用的配置的一部分。</li></ul><p>说明： </p><ul><li>SELECTED标志表示该DAQ列表已被前一个START_STOP_DAQ_LIST(选择)。如果下一个命令是START_STOP_SYNCH，这将启动/停止此DAQ列表。如果下一个命令是SET_REQUEST，这将使DAQ列表成为配置的一部分之后将被清除或存储到非易失性内存中。</li><li>DIRECTION标志指示该DAQ列表是否为同步数据配置获得或刺激。</li><li>RUNNING标志表示DAQ列表已由主服务器主动启动START_STOP_DAQ_LIST或START_STOP_SYNCH，或者slave在RESUME中mode自动启动DAQ列表。RESUME标志表示此DAQ列表是RESUME中使用的配置的一部分模式。</li></ul><h4 id="0xDE-START-STOP-DAQ-LIST"><a href="#0xDE-START-STOP-DAQ-LIST" class="headerlink" title="0xDE:START_STOP_DAQ_LIST"></a>0xDE:START_STOP_DAQ_LIST</h4><p><img src="/image/xcpcmd/START_STOP_DAQ_LIST.png" alt="START_STOP_DAQ_LIST"></p><p>Mode参数：</p><ul><li>00：停止</li><li>01：启动</li><li>02：选择</li></ul><p>此命令可用于预定义的和可配置的DAQ列表，因此范围DAQ_LIST_NUMBER是[0,1，..MAX_DAQ-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。<br>此命令用于启动、停止或准备指定的同步启动DAQ_LIST_NUMBER。mode参数允许启动或停止特定的DAQ列表。选择模式使用提供的参数配置DAQ列表，但不启动指定列表的数据传输。此模式用于同步启动/停止所有配置的DAQ列表(参考START_STOP_SYNCH)或用于RESUME模式(参考SET_REQUEST)。<br>从设备必须快速在GET_DAQ_LIST_MODE模式中重置SELECTED标志因为START_STOP_SYNCH或SET_REQUEST已被确认。<br>如果至少有一个DAQ列表已经启动，则从设备处于数据传输模式。GET_STATUS命令将返回DAQ_RUNNING状态。</p><ul><li>如果DTO报文的标识字段类型为absolute ODT number，则FIRST_PID为此DAQ列表传输的第一个ODT的DTO包中的绝对ODT号。</li><li>任何其他ODT的绝对ODT数可以通过以下方式确定:<br>Absolute_ODT_number(ODT i in DAQ list j) = FIRST_PID(DAQ list j) + relative_ODT_NUMBER(ODT i) </li><li>如果DTO报文标识字段类型为relative ODT number and absolute DAQ list number， FIRST_PID可以忽略。</li></ul><h4 id="0xDD-START-STOP-SYNCH"><a href="#0xDD-START-STOP-SYNCH" class="headerlink" title="0xDD:START_STOP_SYNCH"></a>0xDD:START_STOP_SYNCH</h4><p><img src="/image/xcpcmd/START_STOP_SYNCH.png" alt="START_STOP_SYNCH"></p><p>该命令用于同步启停数据的传输采集列表。<br>所有的DAQ列表或仅到选定的列表(以前配置为START_STOP_DAQ_LIST(选择))。从设备必须重置DAQ表的SELECTED，在成功执行START_STOP_SYNCH后。</p><p>Mode参数：</p><ul><li>00：停止所有</li><li>01：启动被选择的</li><li>02：停止被选择的</li></ul><h3 id="可选实现指令-3"><a href="#可选实现指令-3" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xDC-GET-DAQ-CLOCK"><a href="#0xDC-GET-DAQ-CLOCK" class="headerlink" title="0xDC:GET_DAQ_CLOCK"></a>0xDC:GET_DAQ_CLOCK</h4><p><img src="/image/xcpcmd/GET_DAQ_CLOCK.png" alt="GET_DAQ_CLOCK"></p><p>同步空闲的运行数据采集时钟数据采集时钟。这是可选的。</p><h4 id="0xDB-READ-DAQ"><a href="#0xDB-READ-DAQ" class="headerlink" title="0xDB:READ_DAQ"></a>0xDB:READ_DAQ</h4><p><img src="/image/xcpcmd/READ_DAQ.png" alt="READ_DAQ"></p><p>读取由DAQ列表指针定义的DAQ列表的一个ODT条目。DAQ表指针在同一个ODT中递增(参见WRITE_DAQ)。<br>READ_DAQ可以用于预定义的和可配置的DAQ列表中的元素。因此上面SET_DAQ_PTR中使用的DAQ_LIST_NUMBER可以在这个范围内[0,1,…MAX_DAQ-1]。</p><blockquote><p>ODT条目的大小必须满足粒度和最大值的规则。(ref GET_DAQ_RESOLUTION_INFO)。</p></blockquote><h4 id="0xDA-GET-DAQ-PROCESSOR-INFO"><a href="#0xDA-GET-DAQ-PROCESSOR-INFO" class="headerlink" title="0xDA:GET_DAQ_PROCESSOR_INFO"></a>0xDA:GET_DAQ_PROCESSOR_INFO</h4><p><img src="/image/xcpcmd/GET_DAQ_PROCESSOR_INFO.png" alt="GET_DAQ_PROCESSOR_INFO"></p><p>PROPERTIES参数：</p><ul><li>DAQ_CONFIG_TYPE=0：静态DAQ列表配置</li><li>DAQ_CONFIG_TYPE=1：动态DAQ列表配置</li><li>PRESCALER_SUPPORTED=0：不支持预分频</li><li>PRESCALER_SUPPORTED=1：支持预分频</li><li>RESUME_SUPPORTED=0：DAQ列表不能设置为RESUME模式</li><li>RESUME_SUPPORTED=1：DAQ列表能设置为RESUME模式</li><li>BIT_STIM_SUPPORTED=0：不支持按位数据刺激</li><li>BIT_STIM_SUPPORTED=1：支持按位数据刺激</li><li>TIMESTAMP_SUPPORTED=0：不支持时间戳模式</li><li>TIMESTAMP_SUPPORTED=1：支持时间戳模式</li><li>PID_OFF_SUPPORTED=0：标识字段不能关闭</li><li>PID_OFF_SUPPORTED=1：标识字段能关闭</li><li>OVERLOAD_EVENT、OVERLOAD_MSB=00：无过载指示</li><li>OVERLOAD_EVENT、OVERLOAD_MSB=01：PID的MSB过载指示</li><li>OVERLOAD_EVENT、OVERLOAD_MSB=10：事件包的过载指示</li><li>OVERLOAD_EVENT、OVERLOAD_MSB=11：不允许出现该状态</li></ul><p>为指示超限情况，从机可以设置的最大位(MSB)的下一个发送成功的报文的PID。当使用PID的MSB时ODT的最大数量(绝对或相对)是有限的，并且必须在范围:<br>0x00&lt;= ODT_NUMBER(DAQ with overrun_msb)&lt;=0x7C</p><p>DAQ_KEY_BYTE参数：</p><ul><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0000：OM_DEFAULT</li><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0001：OM_ODT_TYPE_16 </li><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0010：OM_ODT_TYPE_32</li><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0011：OM_ODT_TYPE_64</li><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0100：OM_ODT_TYPE_ALIGNMENT</li><li>Optimisation_Type_3、Optimisation_Type_2、Optimisation_Type_1、Optimisation_Type_0=0101：OM_MAX_ENTRY_SIZE</li><li>Address_Extension_DAQ、Address_Extension_ODT=00：在同一个ODT中，地址扩展名可以不同。</li><li>Address_Extension_DAQ、Address_Extension_ODT=01：一个ODT内的所有条目的地址扩展名必须相同。</li><li>Address_Extension_DAQ、Address_Extension_ODT=10：不允许状态。</li><li>Address_Extension_DAQ、Address_Extension_ODT=11：一个DAQ内的所有条目的地址扩展必须相同。</li><li>Identification_Field_Type_1、Identification_Field_Type_0=00：ODT绝对编号</li><li>Identification_Field_Type_1、Identification_Field_Type_0=01：相对ODT号，绝对DAQ列表号(BYTE)</li><li>Identification_Field_Type_1、Identification_Field_Type_0=10：ODT相对编号，DAQ绝对编号(WORD)</li><li>Identification_Field_Type_1、Identification_Field_Type_0=11：相对ODT编号，绝对DAQ列表编号(WORD，对齐)</li></ul><h4 id="0xD9-GET-DAQ-RESOLUTION-INFO"><a href="#0xD9-GET-DAQ-RESOLUTION-INFO" class="headerlink" title="0xD9:GET_DAQ_RESOLUTION_INFO"></a>0xD9:GET_DAQ_RESOLUTION_INFO</h4><p><img src="/image/xcpcmd/GET_DAQ_RESOLUTION_INFO.png" alt="GET_DAQ_RESOLUTION_INFO"></p><p>GRANULARITY_ODT_ENTRY_SIZE_x的可能值是{1,2,4,8}。对于ODT条目所描述的元素的地址，必须满足以下要求:<br>Address mod GRANULARITY_ODT_ENTRY_SIZE_x = 0 </p><p>对于ODT条目描述的每个元素大小，必须满足以下要求:<br>SizeOf(element described by ODT entry)mod GRANULARITY_ODT_ENTRY_SIZE_x = 0</p><p>参数MAX_ODT_ENTRY_SIZE_x表示ODT条目描述的元素。对于ODT条目描述的每个元素大小，必须满足以下要求:<br>SizeOf(element described by ODT entry) &lt;= MAX_ODT_ENTRY_SIZE_x </p><p>如果从机不支持时间戳模式(GET_DAQ_PROCESSOR_INFO中没有TIMESTAMP_SUPPORTED)、参数TIMESTAMP_MODE和TIMESTAMP_TICKS无效。</p><p>如果从设备支持时间戳模式，则TIMESTAMP_MODE和TIMESTAMP_TICKS包含数据采集时钟的分辨率信息。数据采集时钟是一个自由运行的计数器，永远不会被重置或修改。</p><p>TIMESTAMP_MODE参数：</p><ul><li>Size_2、Size_1、Size_0=000：时间戳的大小(字节) = 没有</li><li>Size_2、Size_1、Size_0=001：时间戳的大小(字节) = 1</li><li>Size_2、Size_1、Size_0=010：时间戳的大小(字节) = 2</li><li>Size_2、Size_1、Size_0=011：时间戳的大小(字节) = 不允许</li><li>Size_2、Size_1、Size_0=100：时间戳的大小(字节) = 4</li><li>TIMESTAMP_FIXED标志表示Slave总是发送DTO报文(stamped mode)。</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0000： DAQ_TIMESTAMP_UNIT_1NS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0001： DAQ_TIMESTAMP_UNIT_10NS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0010： DAQ_TIMESTAMP_UNIT_100NS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0011： DAQ_TIMESTAMP_UNIT_1US</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0100： DAQ_TIMESTAMP_UNIT_10US</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0101： DAQ_TIMESTAMP_UNIT_100US</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0110： DAQ_TIMESTAMP_UNIT_1MS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=0111： DAQ_TIMESTAMP_UNIT_10MS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=1000： DAQ_TIMESTAMP_UNIT_100MS</li><li>Unit_3、Unit_2、Unit_1、Unit_0=1001： DAQ_TIMESTAMP_UNIT_1S</li></ul><h4 id="0xD8-GET-DAQ-LIST-INFO"><a href="#0xD8-GET-DAQ-LIST-INFO" class="headerlink" title="0xD8:GET_DAQ_LIST_INFO"></a>0xD8:GET_DAQ_LIST_INFO</h4><p><img src="/image/xcpcmd/GET_DAQ_LIST_INFO.png" alt="GET_DAQ_LIST_INFO"></p><p>GET_DAQ_LIST_INFO返回特定DAQ列表的信息。此命令可用于预定义的和可配置的DAQ列表，因此范围DAQ_LIST_NUMBER是[0,1，..MAX_DAQ-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</p><p>PROPERTIES参数：</p><ul><li>PREDEFINED=0：可更改DAQ列表配置</li><li>PREDEFINED=1：DAQ列表配置固定</li><li>EVENT_FIXED=0：事件通道可以更改</li><li>EVENT_FIXED=1：事件通道配置固定</li><li>STIM、DAQ=00：不允许</li><li>STIM、DAQ=01：DAQ_LIST_TYPE：仅在DIRECTION = DAQ支持</li><li>STIM、DAQ=10：DAQ_LIST_TYPE：仅在DIRECTION = STIM支持</li><li>STIM、DAQ=11：DAQ_LIST_TYPE：在支持两个方向(但不同时)</li></ul><p>如果静态配置DAQ列表，则MAX_ODT指定该DAQ的odt数量和MAX_ODT_ENTRIES表示每个ODT中ODT表项的个数。<br>FIXED_EVENT表示用于此DAQ列表的固定事件通道的编号。</p><h4 id="0xD7-GET-DAQ-EVENT-INFO"><a href="#0xD7-GET-DAQ-EVENT-INFO" class="headerlink" title="0xD7:GET_DAQ_EVENT_INFO"></a>0xD7:GET_DAQ_EVENT_INFO</h4><p><img src="/image/xcpcmd/GET_DAQ_EVENT_INFO.png" alt="GET_DAQ_EVENT_INFO"></p><p>GET_DAQ_EVENT_INFO返回特定事件通道的信息。的数字。从0到MAX_EVENT_CHANNEL-1指定事件通道。如果指定如果事件通道不可用，则返回ERR_OUT_OF_RANGE。</p><p>PROPERTIES参数：</p><ul><li>STIM 、DAQ=00：不允许</li><li>STIM 、DAQ=01：EVENT_CHANNEL_TYPE：仅支持DIRECTION = DAQ列表</li><li>STIM 、DAQ=10：EVENT_CHANNEL_TYPE：仅支持DIRECTION = STIM列表</li><li>STIM 、DAQ=11：EVENT_CHANNEL_TYPE：两种都支持(同时)</li></ul><p>MAX_DAQ_LIST可分配的最大DAQ列表数量事件通道。MAX_DAQ_LIST = 0x00表示此事件可用，但当前为不可用。MAX_DAQ_LIST = 0xFF表示不受限。<br>该命令会自动将从MTA (Memory Transfer Address)中上传事件通道名称，使用一个或多个UPLOAD命令。事件通道名称length指定名称中的ASCII字节数。不包含结尾\0。<br>事件通道时间周期指示从设备处理该事件的采样周期事件通道。有关事件通道时间单位的定义，请参阅时间戳单位。<br>事件通道优先级指定此事件通道的优先级从机处理不同的事件通道。这个优先级是一个固定的属性<br>，因此是只读的。事件通道与事件通道priority = FF优先级最高。</p><h2 id="数据采集-DAQ-指令-动态"><a href="#数据采集-DAQ-指令-动态" class="headerlink" title="数据采集(DAQ)指令(动态)"></a>数据采集(DAQ)指令(动态)</h2><h3 id="可选实现指令-4"><a href="#可选实现指令-4" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xD6-FREE-DAQ"><a href="#0xD6-FREE-DAQ" class="headerlink" title="0xD6:FREE_DAQ"></a>0xD6:FREE_DAQ</h4><p><img src="/image/xcpcmd/FREE_DAQ.png" alt="FREE_DAQ"></p><p>该命令清除所有的DAQ列表，并释放所有动态分配的DAQ列表，ODT和ODT条目。在动态DAQ列表配置序列的开始，总主总是首先必须发送一个FREE_DAQ。</p><h4 id="0xD5-ALLOC-DAQ"><a href="#0xD5-ALLOC-DAQ" class="headerlink" title="0xD5:ALLOC_DAQ"></a>0xD5:ALLOC_DAQ</h4><p><img src="/image/xcpcmd/ALLOC_DAQ.png" alt="ALLOC_DAQ"></p><ul><li>这个命令为XCP从设备分配了一些DAQ列表。如果没有足够的内存来分配请求的DAQ列表ERR_MEMORY_OVERFLOW将作为负响应返回。</li><li>主设备必须按照定义的顺序使用ALLOC_DAQ和FREE_DAQ，ALLOC_ODT和ALLOC_ODT_ENTRY。如果主服务器直接发送ALLOC_DAQ和ALLOC_ODT而没有发送FREE_DAQ，则从服务器返回ERR_SEQUENCE作为消极的回应。</li><li>如果主设备直接在ALLOC_ODT_ENTRY之后发送一个ALLOC_DAQ，而没有在之间发送FREE_DAQ，从服务器返回一个ERR_SEQUENCE作为负响应。</li></ul><h4 id="0xD4-ALLOC-ODT"><a href="#0xD4-ALLOC-ODT" class="headerlink" title="0xD4:ALLOC_ODT"></a>0xD4:ALLOC_ODT</h4><p><img src="/image/xcpcmd/ALLOC_ODT.png" alt="ALLOC_ODT"></p><ul><li>该命令分配多个odt，并将它们分配到指定的DAQ列表中。此命令只能用于可配置的DAQ列表，因此DAQ_LIST_NUMBER是[MIN_DAQ, MIN_DAQ+1，..MIN_DAQ+DAQ_COUNT-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。</li><li>如果没有足够的内存来分配请求的odt，ERR_MEMORY_OVERFLOW将作为负响应返回。</li><li>主设备必须按照定义的顺序使用ALLOC_DAQ和FREE_DAQ，ALLOC_ODT和ALLOC_ODT_ENTRY。如果主服务器直接发送ALLOC_DAQ和ALLOC_ODT而没有发送FREE_DAQ，则从服务器返回ERR_SEQUENCE作为消极的回应。</li><li>如果主设备直接在ALLOC_ODT_ENTRY之后发送一个ALLOC_DAQ，而没有在之间发送FREE_DAQ，从服务器返回一个ERR_SEQUENCE作为负响应。</li></ul><h4 id="0xD3-ALLOC-ODT-ENTRY"><a href="#0xD3-ALLOC-ODT-ENTRY" class="headerlink" title="0xD3:ALLOC_ODT_ENTRY"></a>0xD3:ALLOC_ODT_ENTRY</h4><p><img src="/image/xcpcmd/ALLOC_ODT_ENTRY.png" alt="ALLOC_ODT_ENTRY"></p><ul><li>该命令分配若干ODT表项，并将它们分配给中指定的ODT具体的DAQ名单。</li><li>此命令只能用于可配置的DAQ列表，因此DAQ_LIST_NUMBER是[MIN_DAQ, MIN_DAQ+1，..MIN_DAQ+DAQ_COUNT-1]。如果指定的列表不可用，则返回ERR_OUT_OF_RANGE。ODT_NUMBER是该DAQ列表中的相对ODT编号。</li><li>如果没有足够的内存来分配请求的ODT项ERR_MEMORY_OVERFLOW将作为负响应返回。</li><li>主设备必须按照定义的顺序使用ALLOC_DAQ和FREE_DAQ，ALLOC_ODT和ALLOC_ODT_ENTRY。如果主服务器直接发送ALLOC_DAQ和ALLOC_ODT而没有发送FREE_DAQ，则从服务器返回ERR_SEQUENCE作为消极的回应。</li><li>如果主设备直接在ALLOC_ODT_ENTRY之后发送一个ALLOC_DAQ，而没有在之间发送FREE_DAQ，从服务器返回一个ERR_SEQUENCE作为负响应。</li></ul><h2 id="存储器编程-PGM-指令"><a href="#存储器编程-PGM-指令" class="headerlink" title="存储器编程(PGM)指令"></a>存储器编程(PGM)指令</h2><h3 id="必实现指令-4"><a href="#必实现指令-4" class="headerlink" title="必实现指令"></a>必实现指令</h3><h4 id="0xD2-PROGRAM-START"><a href="#0xD2-PROGRAM-START" class="headerlink" title="0xD2:PROGRAM_START"></a>0xD2:PROGRAM_START</h4><p><img src="/image/xcpcmd/PROGRAM_START.png" alt="PROGRAM_START"></p><ul><li>此命令用于指示非易失性内存编程的开始序列。如果从设备不处于允许编程的状态将返回ERR_GENERIC。</li><li>内存编程命令PROGRAM_CLEAR, PROGRAM, PROGRAM_MAX或PROGRAM_NEXT不允许，<br>直到成功执行PROGRAM_START命令前。</li><li>非volatile内存编程序列的结束由PROGRAM_RESET命令指示。</li></ul><p>内存编程序列:</p><ol><li>SET_MTA </li><li>PROGRAM_CLEAR </li><li>PROGRAM </li><li>PROGRAM_MAX or PROGRAM_NEXT </li></ol><p>以下命令是可选的(例如验证内存内容): UPLOAD、BUILD_CHECKSUM </p><p>如果非易失性内存编程需要下载额外的代码，下载必须在执行PROGRAM_START命令之前完成。MTA必须指向已下载例程的入口点。</p><p>COMM_MODE参数：</p><ul><li>MASTER_BLOCK_MODE：标志表示主机块模式是否可用</li><li>INTERLEAVED_MODE：标志表示在此期间交错模式是否可用</li><li>SLAVE_BLOCK_MODE：标志表示从机块模式在此期间是否可用</li></ul><p>通信参数MAX_CTO、MAX_BS、MIN_ST和QUEUE_SIZE可能会被修改当从设备处于内存编程模式时。<br>新的通信参数为MAX_CTO_PGM、MAX_BS_PGM、MIN_ST_PGM和QUEUE_SIZE_PGM在回应中返回。</p><h4 id="0xD1-PROGRAM-CLEAR"><a href="#0xD1-PROGRAM-CLEAR" class="headerlink" title="0xD1:PROGRAM_CLEAR"></a>0xD1:PROGRAM_CLEAR</h4><p><img src="/image/xcpcmd/PROGRAM_CLEAR.png" alt="PROGRAM_CLEAR"></p><p>该命令用于在重编程之前清除一部分非易失性内存。</p><p>Mode参数：</p><ul><li>0x00：绝对访问模式(默认)</li><li>0x01：功能访问模式</li></ul><p>绝对访问模式(Absolute Access mode):</p><ul><li>MTA指向从机内部内存扇区的开始。内存扇区在ASAM MCD 2MC从设备中描述文件。</li><li>如果需要按一定的顺序清除多个内存扇区，则主设备必须使用新的MTA重复PROGRAM_CLEAR服务。在这种情况下，必须保留Clear提供的扇区序列号。</li><li>“Clear Range”表示需要清除的内存部分的长度。PROGRAM_CLEAR服务一次清除一个完整的扇区或多个扇区。</li></ul><p>功能访问模式(Functional Access mode):</p><ul><li>MTA功能模式没有影响</li><li>0x00000001：清除所有校准数据区域</li><li>0x00000002：清除所有的代码区(引导区不被覆盖)</li><li>0x00000004：清除NVRAM区域(s)</li><li>0x00000008-0x00000080：保留</li><li>0x00000100-0xFFFFFF00：用户自定义</li></ul><h4 id="0xD0-PROGRAM"><a href="#0xD0-PROGRAM" class="headerlink" title="0xD0:PROGRAM"></a>0xD0:PROGRAM</h4><p><img src="/image/xcpcmd/PROGRAM.png" alt="PROGRAM"></p><ul><li>如果ADDRESS_GRANULYRITY = DWORD，必须使用2个对齐字节才能满足需求。</li><li>元素是BYTE、WORD或DWORD，取决于AG。</li><li>该命令用于对从机内部的数据进行编程。取决于访问模式(由PROGRAM_FORMAT定义)支持2个不同的概念。</li><li>当数据元素的数量为0时，表示内存段的结束。</li><li>整个编程序列的结束由PROGRAM_RESET表示。从设备将进入断开连接状态。通常是硬件复位<br>从设备执行。此命令可能支持块传输，类似命令DOWNLOAD和DOWNLOAD_NEXT。</li></ul><p>绝对访问模式：</p><ul><li>CTO中包含的指定长度(大小)的数据块将被编程非易失性存储器，从MTA开始。MTA将会增加这个数据字节。</li><li>如果需要对多个内存扇区进行编程，则主设备必须保持在IF_DATA描述中给出的信息称为的编程序列号。</li></ul><p>功能访问方式：</p><ul><li>CTO中包含的指定长度(大小)的数据块将被编程非易失性内存。ECU软件知道新flash内容的起始地址，这取决于PROGRAM_CLEAR命令。ECU期待新的flash内容在一个数据流和分配是由ECU自动完成。</li></ul><h4 id="0xCF-PROGRAM-RESET"><a href="#0xCF-PROGRAM-RESET" class="headerlink" title="0xCF:PROGRAM_RESET"></a>0xCF:PROGRAM_RESET</h4><p><img src="/image/xcpcmd/PROGRAM_RESET.png" alt="PROGRAM_RESET"></p><p>此可选命令指示非易失性内存编程序列的结束。它可能会有反应，也可能不会。不管是哪种情况，从设备都会转到断开连接的状态。此命令可用于强制从设备复位。</p><h3 id="可选实现指令-5"><a href="#可选实现指令-5" class="headerlink" title="可选实现指令"></a>可选实现指令</h3><h4 id="0xCE-GET-PGM-PROCESSOR-INFO"><a href="#0xCE-GET-PGM-PROCESSOR-INFO" class="headerlink" title="0xCE:GET_PGM_PROCESSOR_INFO"></a>0xCE:GET_PGM_PROCESSOR_INFO</h4><p><img src="/image/xcpcmd/GET_PGM_PROCESSOR_INFO.png" alt="GET_PGM_PROCESSOR_INFO"></p><p>PROPERTIES参数：</p><ul><li>FUNCTIONAL_MODE、ABSOLUTE_MODE=00：清除编程模式 -&gt; 不允许</li><li>FUNCTIONAL_MODE、ABSOLUTE_MODE=01：清除编程模式 -&gt; 只支持绝对模式</li><li>FUNCTIONAL_MODE、ABSOLUTE_MODE=10：清除编程模式 -&gt; 仅支持功能模式</li><li>FUNCTIONAL_MODE、ABSOLUTE_MODE=11：清除编程模式 -&gt; 都支持</li><li>COMPRESSION_REQUIRED、COMPRESSION_SUPPORTED=00：压缩 -&gt; 不支持</li><li>COMPRESSION_REQUIRED、COMPRESSION_SUPPORTED=01：压缩 -&gt; 支持</li><li>COMPRESSION_REQUIRED、COMPRESSION_SUPPORTED=10：压缩 -&gt; 支持、可请求</li><li>COMPRESSION_REQUIRED、COMPRESSION_SUPPORTED=11：压缩 -&gt; 支持、可请求</li><li>ENCRYPTION_REQUIRED、ENCRYPTION_SUPPORTED=00：编码 -&gt; 不支持</li><li>ENCRYPTION_REQUIRED、ENCRYPTION_SUPPORTED=01：编码 -&gt; 支持</li><li>ENCRYPTION_REQUIRED、ENCRYPTION_SUPPORTED=10：编码 -&gt; 支持、可请求</li><li>ENCRYPTION_REQUIRED、ENCRYPTION_SUPPORTED=11：编码 -&gt; 支持、可请求</li><li>NON_SEQ_PGM_REQUIRED、NON_SEQ_PGM_SUPPORTED=00：不连续编程 -&gt; 不支持</li><li>NON_SEQ_PGM_REQUIRED、NON_SEQ_PGM_SUPPORTED=01：不连续编程 -&gt; 支持</li><li>NON_SEQ_PGM_REQUIRED、NON_SEQ_PGM_SUPPORTED=10：不连续编程 -&gt; 支持、可请求</li><li>NON_SEQ_PGM_REQUIRED、NON_SEQ_PGM_SUPPORTED=11：不连续编程 -&gt; 支持、可请求</li></ul><h4 id="0xCD-GET-SECTOR-INFO"><a href="#0xCD-GET-SECTOR-INFO" class="headerlink" title="0xCD:GET_SECTOR_INFO"></a>0xCD:GET_SECTOR_INFO</h4><p><img src="/image/xcpcmd/GET_SECTOR_INFO.png" alt="GET_SECTOR_INFO"></p><p>GET_SECTOR_INFO返回特定扇区的信息。如果指定的扇区不可用，则返回ERR_OUT_OF_RANGE。此可选命令仅对编程方法“绝对访问模式”有帮助。</p><h4 id="0xCC-PROGRAM-PREPARE"><a href="#0xCC-PROGRAM-PREPARE" class="headerlink" title="0xCC:PROGRAM_PREPARE"></a>0xCC:PROGRAM_PREPARE</h4><p><img src="/image/xcpcmd/PROGRAM_PREPARE.png" alt="PROGRAM_PREPARE"></p><p>此可选命令用于先决条件的代码下载到非易失性内存开始前。MTA指向易失性存储器的开始存储代码的位置。参数Codesize指定将被下载的代码大小。下载是使用后续标准完成的命令，如SET_MTA和DOWNLOAD。<br>代码大小根据AG以BYTE、WORD或DWORD表示。从设备必须确保目标内存区域是可用的，并且它在允许下载代码的操作状态。如果不是，则ERR_GENERIC将返回。</p><h4 id="0xCB-PROGRAM-FORMAT"><a href="#0xCB-PROGRAM-FORMAT" class="headerlink" title="0xCB:PROGRAM_FORMAT"></a>0xCB:PROGRAM_FORMAT</h4><p><img src="/image/xcpcmd/PROGRAM_FORMAT.png" alt="PROGRAM_FORMAT"></p><p>Compression参数：</p><ul><li>0x00：数据未压缩(默认)</li><li>0x80-0xFF：用户定义</li></ul><p>Encryption参数：</p><ul><li>0x00：数据未编码(默认)</li><li>0x80-0xFF：用户定义</li></ul><p>Programming参数：</p><ul><li>0x00：顺序编程(默认)</li><li>0x80-0xFF：用户定义</li></ul><p>Access参数：</p><ul><li>0x00：绝对访问模式(默认)  MTA使用物理地址</li><li>0x01：功能访问方式     MTA的功能是一个新flash内容文件的序列号</li><li>0x80-0xFF：用户定义</li></ul><p>受该指令影响的指令：PROGRAM, PROGRAM_MAX, PROGRAM_NEXT, SET_MTA</p><p>Example：<br>…<br>SET_MTA<br>PROGRAM_FORMAT<br>PROGRAM<br>PROGRAM_NEXT1..n<br>…</p><h4 id="0xCA-PROGRAM-NEXT"><a href="#0xCA-PROGRAM-NEXT" class="headerlink" title="0xCA:PROGRAM_NEXT"></a>0xCA:PROGRAM_NEXT</h4><p><img src="/image/xcpcmd/PROGRAM_NEXT.png" alt="PROGRAM_NEXT"></p><blockquote><p>如果AG = DWORD，则必须使用2个对齐字节以满足对齐要求。<br>ELEMENT是BYTE, WORD或DWORD，取决于AG。<br>该命令用于为PROGRAM命令传输连续的数据字节块传输模式。</p></blockquote><p>如果数据元素的数量与期望值不匹配，则错误码将返回code ERR_SEQUENCE。回应将包含预期的数据元素数量。</p><h4 id="0xC9-PROGRAM-MAX"><a href="#0xC9-PROGRAM-MAX" class="headerlink" title="0xC9:PROGRAM_MAX"></a>0xC9:PROGRAM_MAX</h4><p><img src="/image/xcpcmd/PROGRAM_MAX.png" alt="PROGRAM_MAX"></p><blockquote><p>根据AG的不同，必须使用1或3个对齐字节来满足对齐要求。<br>ELEMENT是BYTE, WORD或DWORD，取决于AG。<br>CTO中包含的MAX_CTO-1元素长度固定的数据块为编程到非易失性存储器中，从MTA开始。MTA将进行后增量MAX_CTO-1。<br>此命令不支持块传输，也不能在块传输中使用序列。</p></blockquote><h4 id="0xC8-PROGRAM-VERIFY"><a href="#0xC8-PROGRAM-VERIFY" class="headerlink" title="0xC8:PROGRAM_VERIFY"></a>0xC8:PROGRAM_VERIFY</h4><p><img src="/image/xcpcmd/PROGRAM_VERIFY.png" alt="PROGRAM_VERIFY"></p><p>使用Mode = 00，主机可以请求从机启动内部测试例程来检查新的flash内容是否验算等于flash的其余部分。<br>使用Mode = 01，主机可以告诉从机，发送给从机一个验证值。</p><p>Verification Type参数：</p><ul><li>0x0001：calibration area(s) of the flash</li><li>0x0002：code area(s) of the flash</li><li>0x0004：complete flash content</li><li>0x0008-0x0080：保留</li><li>0x0100-0xFF00：用户定义</li></ul>]]></content>
      
      
      <categories>
          
          <category> protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCP </tag>
            
            <tag> 标定 </tag>
            
            <tag> 汽车控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞萨芯片在CS+中分区方法</title>
      <link href="/mcu/rui-sa-xin-pian-zai-cs-zhong-fen-qu-fang-fa/"/>
      <url>/mcu/rui-sa-xin-pian-zai-cs-zhong-fen-qu-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="瑞萨芯片在CS-中分区方法"><a href="#瑞萨芯片在CS-中分区方法" class="headerlink" title="瑞萨芯片在CS+中分区方法"></a>瑞萨芯片在CS+中分区方法</h2><p>CS+的分区是以图形配置。需要添加分区时，先规划好分区的地址，然后来section来添加。</p><h3 id="进入分区"><a href="#进入分区" class="headerlink" title="进入分区"></a>进入分区</h3><p><img src="/image/rscs/section.png" alt="进入分区设置"></p><h3 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h3><p>注意添加分区时先添加地址栏，然后在新建地址栏后面建立标签。</p><p><img src="/image/rscs/add.png" alt="增加分区设置"></p><h3 id="添加分区名称"><a href="#添加分区名称" class="headerlink" title="添加分区名称"></a>添加分区名称</h3><p>填写自己分区名字后需要在后面添加分区类型：.bss .data .const .text</p><ul><li>.bss：表示该分区存储的变量没有初始值，一般直接使用给RAM的分区后缀。</li><li>.data：表示该分区存储的变量有初始值，如果该区在RAM，会没有初始值。</li><li>.test：表示该分区存储代码段。一般用于ROM。</li></ul><p><img src="/image/rscs/name.png" alt="分区类型"></p><h3 id="代码中使用分区"><a href="#代码中使用分区" class="headerlink" title="代码中使用分区"></a>代码中使用分区</h3><p>如下代码，使用分区CAL，则编译器会查找CAL.data段来存储该变量。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">section r0_disp32 </span><span class="token string">"CAL"</span></span><span class="token keyword">char</span> test<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">section</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分区映射"><a href="#分区映射" class="headerlink" title="分区映射"></a>分区映射</h3><p>一般.data有RAM和ROM。ROM用于存储初始值。RAM是代码寻址使用的地址，如果只有RAM则该变量没有初始值，只有ROM则该变量不能修改。地址映射，则是将ROM存储的变量的地址映射到RAM区。</p><p><img src="/image/rscs/map.png" alt="分区地址映射"></p><h3 id="上电数据迁移"><a href="#上电数据迁移" class="headerlink" title="上电数据迁移"></a>上电数据迁移</h3><p>地址映射完成但是该RAM区上电是没有初值的，需要代码进行搬移。</p><p><img src="/image/rscs/datainit.png" alt="分区初始化"></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; when the section has the initial value.section    &quot;.INIT_DSEC_PE0.const&quot;, const.align      4.dw   #__s.data,  #__e.data,  #__s.data.R.dw         #__s.PE0.data,  #__e.PE0.data,  #__s.PE0.data.R.dw         #__sCAL.data,  #__eCAL.data,  #__sCAL_RAM.data; when the section without initial value.section    &quot;.INIT_BSEC_PE0.const&quot;, const.align      4.dw         #__s.bss,   #__e.bss.dw         #__s.PE0.bss,   #__e.PE0.bss;.dw   #__s.R_RFD_BSS.bss, #__e.R_RFD_BSS.bss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ol><li>.INIT_DSEC_PE0.const分区是放的需要数据搬移的起始结束地址，.INIT_BSEC_PE0.const分区是放的需要数据初始化为0的起始结束地址。该文件后面会有具体数据搬移和初始化为0的代码。</li><li>需要分区搬移数据的分区标号可以在map文件中查看</li></ol>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瑞萨 </tag>
            
            <tag> CS+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标定基础-XCP协议之协议层</title>
      <link href="/protocol/biao-ding-ji-chu-xcp-xie-yi-zhi-xie-yi-ceng/"/>
      <url>/protocol/biao-ding-ji-chu-xcp-xie-yi-zhi-xie-yi-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="XCP协议背景"><a href="#XCP协议背景" class="headerlink" title="XCP协议背景"></a>XCP协议背景</h2><p>CCP协议是基于CAN的标定协议，随着发展标定不再满足于CAN通信，因此发展出XCP来支持CAN、USB、TCP/IP、UDP/IP。它与CCP具有渊源。</p><p>XCP提供以下基本功能：</p><ul><li>同步数据采集</li><li>同步数据激励</li><li>在线内存校准（读/写访问）</li><li>校准数据页面初始化和切换</li><li>用于ECU开发的Flash编程</li></ul><p>XCP提供以下可选的新功能：</p><ul><li>各种传输层（CAN、以太网、USB、…）</li><li>块通信模式</li><li>交错通信模式</li><li>动态数据传输配置</li><li>时间戳数据传输</li><li>数据传输同步</li><li>数据传输的优先级</li><li>原子位修改</li><li>按位数据刺激</li></ul><p>与CCP 2.1相比，XCP改进了以下功能：</p><ul><li>兼容性和规范</li><li>效率和吞吐量</li><li>开机数据传输</li><li>数据页面冻结</li><li>自动配置</li><li>闪存编程</li></ul><p>XCP是根据以下原则设计的：</p><ul><li>最小的从资源消耗（RAM、ROM、运行时资源）</li><li>高效的通信</li><li>简单的从设备实现</li></ul><h2 id="XCP消息帧结构说明"><a href="#XCP消息帧结构说明" class="headerlink" title="XCP消息帧结构说明"></a>XCP消息帧结构说明</h2><p>所有XCP通信都作为称为XCP数据包的数据对象传输。<br>有2种基本的数据包类型：</p><ol><li>用于传输通用控制命令的数据包：CTO</li><li>用于传输同步数据的数据包：DTO</li></ol><ul><li><p>CTO（命令传输对象）用于传输通用控制命令</p><ul><li>它用于执行协议命令（CMD）</li><li>传输命令响应（RES）</li><li>错误（ERR）数据包</li><li>事件（EV）数据包</li><li>服务请求数据包（SERV）</li></ul></li><li><p>DTO（数据传输对象）用于传输同步数据采集数据（DAQ）和传输同步数据刺激数据（STIM）。</p></li></ul><p><img src="/image/xcp/flow.png" alt="数据流"></p><h2 id="XCP协议的帧格式"><a href="#XCP协议的帧格式" class="headerlink" title="XCP协议的帧格式"></a>XCP协议的帧格式</h2><p><img src="/image/xcp/format.png" alt="帧格式"></p><ol><li>XCP帧格式由头部、数据包、尾部组成，头部尾部根据协议在不同通信方式上有所区别。</li><li>XCP数据包包含协议的通用部分，独立于使用的传输层。</li><li>XCP数据包由标识字段、可选时间戳字段、数据字段组成。</li></ol><h3 id="头部尾部"><a href="#头部尾部" class="headerlink" title="头部尾部"></a>头部尾部</h3><p>头部尾部根据协议在不同通信方式上有所区别。</p><h3 id="标识字段"><a href="#标识字段" class="headerlink" title="标识字段"></a>标识字段</h3><p>XCP数据包基本上总是以标识字段开头，该字段作为第一个字节包含数据包标识符（PID）。</p><h4 id="主设备到从设备的标识字段"><a href="#主设备到从设备的标识字段" class="headerlink" title="主设备到从设备的标识字段"></a>主设备到从设备的标识字段</h4><p><img src="/image/xcp/pidms.png" alt="PID"></p><h4 id="从设备到主设备的标识字段"><a href="#从设备到主设备的标识字段" class="headerlink" title="从设备到主设备的标识字段"></a>从设备到主设备的标识字段</h4><p><img src="/image/xcp/pidsm.png" alt="PID"></p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><ol><li>对于CTO数据包，数据字段包含不同类型的CTO数据包的特定参数。</li><li>对于DTO数据包，数据字段包含用于同步获取和激励的数据。</li></ol><h2 id="CTO"><a href="#CTO" class="headerlink" title="CTO"></a>CTO</h2><p>CTO（Command Transfer Object）用于传输通用控制命令。</p><p><img src="/image/xcp/cto.png" alt="CTO"></p><ol><li>识别字段仅由PID组成，其中包含CTO数据包代码。时间戳字段不可用。</li><li>数据字段包含不同类型的CTO数据包的特定参数。</li></ol><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD（Command Packet）的PID包含0xC0 &lt;= CMD &lt;= 0xFF范围内的代码。所有可能的命令代码都在命令代码（CMD）定义。</p><p><img src="/image/xcp/cmd.png" alt="CMD"></p><h3 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h3><p>RES（Command Response packet）PID包含命令正响应包代码RES = 0xFF。如果命令成功执行，RES将作为CMD的回复发送。</p><p><img src="/image/xcp/res.png" alt="RES"></p><h3 id="ERR"><a href="#ERR" class="headerlink" title="ERR"></a>ERR</h3><p>ERR（Error packet）的PID包含数据包代码ERR = 0xFE。如果命令未成功执行，ERR将作为CMD的响应发送。第二个字节包含错误代码。后续定义了错误代码。</p><p><img src="/image/xcp/err.png" alt="RES"></p><h3 id="EV"><a href="#EV" class="headerlink" title="EV"></a>EV</h3><p>EV（Event packet）的PID包含数据包代码EV = 0xFD。如果从设备想要报告异步事件包，则发送EV。第二个字节包含事件代码。后续定义了事件代码。实现是可选的。从设备发送到主设备的事件数据包无被确认回复，因此不能保证传输。</p><p><img src="/image/xcp/ev.png" alt="EV"></p><h3 id="SERV"><a href="#SERV" class="headerlink" title="SERV"></a>SERV</h3><p>SERV（Service Request packet）的PID包含请求包代码SERV = 0xFC。SERV要求主设备执行一些操作。第二个字节包含服务请求代码。可能的服务请求代码在后续定义。</p><p><img src="/image/xcp/serv.png" alt="SERV"></p><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><p><img src="/image/xcp/dto.png" alt="DTO"></p><p>DTO用于传输同步数据采集数据（DAQ）和传输同步数据刺激数据（STIM）。<br>识别字段的内容因识别字段类型而异。<br>时间戳字段的内容因时间戳字段类型而异。<br>识别字段类型和时间戳字段类型的任何组合都是可能的。<br>数据字段包含用于同步获取和刺激的数据。</p><h3 id="DAQ"><a href="#DAQ" class="headerlink" title="DAQ"></a>DAQ</h3><p>PID包含0x00 &lt;= DAQ &lt;= 0xFB范围内的（绝对或相对）ODT数。ODT编号是指对象描述符表（ODT），该表描述了剩余数据字节中包含哪些数据采集元素。</p><p><img src="/image/xcp/daq.png" alt="DAQ"></p><h3 id="STIM"><a href="#STIM" class="headerlink" title="STIM"></a>STIM</h3><p>PID包含0x00 &lt;= STIM &lt;= 0xBF范围内的（绝对或相对）ODT编号。ODT编号是指相应的对象描述符表（ODT），该表描述了剩余数据字节中包含哪些数据刺激元素。</p><p><img src="/image/xcp/stim.png" alt="STIM"></p><h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><p><img src="/image/xcp/errcode.png" alt="ERROR CODE"></p><h4 id="事件代码"><a href="#事件代码" class="headerlink" title="事件代码"></a>事件代码</h4><p>下表中的事件数据包代码可以作为PID = 0xFD的异步数据包发送。实现是可选的。从设备发送到主设备的事件数据包不被确认，因此不能保证传输。</p><p><img src="/image/xcp/evcode.png" alt="EV CODE"></p><h4 id="服务代码"><a href="#服务代码" class="headerlink" title="服务代码"></a>服务代码</h4><p>下表中的服务请求数据包代码可以作为PID = 0xFC的异步数据包发送。对于从设备来说，实现是可选的，但对于主设备来说是强制性的。从设备发送到主设备的服务请求包不被确认，因此不能保证传输。</p><p><img src="/image/xcp/servcode.png" alt="SERV CODE"></p><h3 id="命令代码"><a href="#命令代码" class="headerlink" title="命令代码"></a>命令代码</h3><h4 id="CMD-STD（标准命令）"><a href="#CMD-STD（标准命令）" class="headerlink" title="CMD-STD（标准命令）"></a>CMD-STD（标准命令）</h4><p><img src="/image/xcp/cmdstd.png" alt="CMD STD"></p><h4 id="CMD-CAL（标定命令）"><a href="#CMD-CAL（标定命令）" class="headerlink" title="CMD-CAL（标定命令）"></a>CMD-CAL（标定命令）</h4><p><img src="/image/xcp/cmdcal.png" alt="CMD CAL"></p><h4 id="CMD-PAG（页切换命令）"><a href="#CMD-PAG（页切换命令）" class="headerlink" title="CMD-PAG（页切换命令）"></a>CMD-PAG（页切换命令）</h4><p><img src="/image/xcp/cmdpag.png" alt="CMD PAG"></p><h4 id="CMD-DAQ（数据采集命令）"><a href="#CMD-DAQ（数据采集命令）" class="headerlink" title="CMD-DAQ（数据采集命令）"></a>CMD-DAQ（数据采集命令）</h4><p><img src="/image/xcp/cmddaq.png" alt="CMD DAQ"></p><h4 id="CMD-PGM（非易失存储编程命令）"><a href="#CMD-PGM（非易失存储编程命令）" class="headerlink" title="CMD-PGM（非易失存储编程命令）"></a>CMD-PGM（非易失存储编程命令）</h4><p><img src="/image/xcp/cmdpgm.png" alt="CMD PGM"></p>]]></content>
      
      
      <categories>
          
          <category> protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCP </tag>
            
            <tag> 标定 </tag>
            
            <tag> 汽车控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标定基础-基于CCP协议</title>
      <link href="/protocol/biao-ding-ji-chu-ji-yu-ccp-xie-yi/"/>
      <url>/protocol/biao-ding-ji-chu-ji-yu-ccp-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>标定协议是汽车控制在编写程序后，部分功能实现的部分参数是需要在实车上才能确定的，当然在实车上调试过程中也需要监测一些数据才能进行调试工作。</p><p>在一些需要调试较少的系统中，可以一边调试一边优化参数重新下载程序。对于汽车这样复杂系统就变得不可能。因此诞生一种标定系统。程序工程师将程序编写架构搭建好，在编程过程中需要预知那些变量需要标定(实时修改)，那些变量需要观测(实时查看)。系统程序搭建好后，标定工程师即可在实车上实时查看、调试控制器。因此诞生一种标定协议。</p><h2 id="标定协议的底层实现"><a href="#标定协议的底层实现" class="headerlink" title="标定协议的底层实现"></a>标定协议的底层实现</h2><p>汽车控制器程序本质运行在SOC上，为了性能和稳定性是无GUI的。因此需要将标定工程师手中的PC作为标定的输入和输出。标定中需要实时和友好的标定软件(电脑端软件)通信。在汽车中广泛存在CAN控制器域网。自然首要选择它作为标定的通信通道。</p><p>汽车控制器的SOC使用C语言。C代码中的参数值可以在RAM(初始值本质在ROM)中，或者ROM中。我们需要标定的参数如果当变量保存在RAM中，则修改后掉电就会恢复为初始值；如果存储在ROM，则不能对其进行修改。</p><p>因此大佬们想了一个办法，标定的参数在SOC上存储两份，RAM、ROM中各一份。当汽车控制器上电是将ROM标定区的数据搬移到RAM标定区，程序运行时使用RAM标定区的参数，标定过程中就能实时修改RAM标定参数，当标定参数确定以后，将RAM标定区数据拷贝到ROM标定区，这样下次上电则是最新的标定参数。</p><p><img src="/image/asap/theory.png" alt="原理"></p><p>当然仅仅只支持标定软件监测的参数(观测量)直接是定义在RAM中的变量，用来实时存储程序运行的部分参数并支持发送给标定软件即可，也不关心存放在ROM的初始值。</p><ul><li>注意：本节主要描述标定底层原理，实际工程系统会复杂一些。</li></ul><h2 id="标定协议规范"><a href="#标定协议规范" class="headerlink" title="标定协议规范"></a>标定协议规范</h2><h3 id="ASAP标准"><a href="#ASAP标准" class="headerlink" title="ASAP标准"></a>ASAP标准</h3><p>是几家德国汽车制造商联手一些著名的汽车电子设备制造商于1991年成立了ASAP标准组织， ASAP的英文全称是The working group for thestandardization of applicationsystems(应用系统标准化工作小组)，它的目标是使在汽车电子设备研发过程中相关的测试，标定，诊断方法及工具能够兼容并互换。</p><p>ASAP3是应用系统，即测试，标定，诊断系统(MCD Measurement， Calibration， Diagnosis System)到自动化系统的接口规范。这里的自动化系统可以是一个测量仪器的指示装置或汽车的燃油测量装置等。</p><p>ASAP2又称为ASAP描述文件，是控制单元内部数据描述文件的规范。 ASAP2文件用来具体描述电子控制单元内部的数据信息，包括数据存储的规范，数字量到物理量的转换规范等。</p><p>ASAP1是控制单元到MCD系统的接口规范，ASAP1规范又细分为ASAP1b与ASAP1a。ASAP1b接口下包括一个符合ASAP标准的驱动程序，硬件接口及电子控制单元。因此ASAP1b接口规范保证了MCD与ECU之间的通信，不受所选通信媒介及不同ECU供应商的限制。其中ASAP1a是到ECU端的数据通信的物理及逻辑接口规范，包括通过CAN总线对ECU进行标定的协议规范。</p><h3 id="ASAM标准组织及其规范"><a href="#ASAM标准组织及其规范" class="headerlink" title="ASAM标准组织及其规范"></a>ASAM标准组织及其规范</h3><p>1998年ASAM小组成立，其英文全称是Association for Standardization of Automation and Measuring System(自动化及测量系统标准化小组)。ASAM标准是ASAP标准的扩展和衍生，在新的ASAM标准中，ASAP标准 变名为ASAM MCD(ASAM Measurement, Calibration and Diagnosis)，原来的ASAP1、ASAP2、ASPA3规范在新的标准下分别为ASAM-MCD 1MC、ASAMMCD 2MC、ASAM-MCD 3MC。</p><p><img src="/image/asap/total.png" alt="架构"></p><h2 id="CCP协议命令格式"><a href="#CCP协议命令格式" class="headerlink" title="CCP协议命令格式"></a>CCP协议命令格式</h2><p>CCP协议是运行在CAN接口之上的标定协议(ASAP1a)，CCP的全称是CAN Calibration Protocol。 CCP协议遵从CAN2.0B通信规范，支持11位标准与29位扩展标识符。数据都是8字节对齐。</p><p><img src="/image/asap/crodto.png" alt="CRODTO"></p><p>CRO是主设备(标定软件)发送给从设备(控制器)的指令；DTO是从设备发送给主设备的数据。</p><ul><li>CRO中CMD(命令码)范围0x00-0xFF，具体含义见指令详解。</li><li>DTO中PID(包识别码)范围0x00-0xFF，具体含义见DTO详解。</li><li>CRO、DTO中的CRT(命令计数码)在一问一答通讯模式中每次加一。对应CRO、DTO的计数码相等。</li></ul><h3 id="DTO详解"><a href="#DTO详解" class="headerlink" title="DTO详解"></a>DTO详解</h3><p><img src="/image/asap/dto.png" alt="DTO"></p><p>DTO的PID分为三类：</p><ol><li>CRM是PID=0xFF的情况，主要是在一问一答通讯模式中回复CRO。</li><li>EM是PID=0xFE的情况，主要是从设备主动发送数据给主设备，例如从设备遇到一些错误等消息需要上报。</li><li>DAQ是PID=0x00-0xFD的情况，主要是数据采集模式下从设备主动发送采集数据到主设备。</li></ol><h3 id="DAQ详解"><a href="#DAQ详解" class="headerlink" title="DAQ详解"></a>DAQ详解</h3><p>DAQ就是从设备向标定软件发送的数据采集信息。也就是将当前控制器中参数发送给标定软件。</p><p><img src="/image/asap/daq.png" alt="DAQ"></p><ul><li>一个ODT表最多有7Byte的数据，一个ODT就对应一个DTO，也就是一帧CAN报文。</li><li>一个DAQ表有多个ODT表。每张DAQ表不可能只有7Byte的数据量，需要多个ODT来传输。</li><li>一个标定系统有多张DAQ表。每张DAQ表的采集周期一般不一样。</li></ul><p>为什么这样区分呢？因为标定系统需要的参数可能需要监测周期不一样。例如一些数据需要10ms报告一次，一些数据需要100ms报告一次。这样利于标定工程师观测参数。因此每张DAQ表的采集周期不一样。</p><h3 id="DAQ举例"><a href="#DAQ举例" class="headerlink" title="DAQ举例"></a>DAQ举例</h3><ul><li>一个标定系统有两张DAQ<ul><li>DAQ#0采集周期为10ms，ODT编号0x00-0x3F。<ul><li>采集数据Data1(uint8) = 0x01</li><li>采集数据Data2(uint32) = 0x00000002</li><li>采集数据Data3(uint32) = 0x00000003</li></ul></li><li>DAQ#1采集周期为100ms，ODT编号0x40-0x7F。<ul><li>采集数据Data4(uint16) = 0x0004</li><li>采集数据Data5(uint32) = 0x00000005</li></ul></li></ul></li></ul><p><img src="/image/asap/daqexp.png" alt="DAQ"></p><h2 id="CCP指令详解"><a href="#CCP指令详解" class="headerlink" title="CCP指令详解"></a>CCP指令详解</h2><h3 id="必须支持指令"><a href="#必须支持指令" class="headerlink" title="必须支持指令"></a>必须支持指令</h3><h4 id="0x01-CONNECT-M"><a href="#0x01-CONNECT-M" class="headerlink" title="0x01: CONNECT(M)"></a>0x01: CONNECT(M)</h4><p><img src="/image/asap/cmd01.png" alt="CONNECT"></p><p>站地址是一个16bit的数字。</p><h4 id="0x17-EXCHANGE-ID-M"><a href="#0x17-EXCHANGE-ID-M" class="headerlink" title="0x17: EXCHANGE_ID(M)"></a>0x17: EXCHANGE_ID(M)</h4><p><img src="/image/asap/cmd17.png" alt="EXCHANGE_ID"></p><p>可用资源掩码: 当bit=TRUE，指定的资源或函数可用。</p><p>保护资源掩码: 当bit=TRUE，指定的资源或功能被保护防止未经授权的访问(需要解锁)。</p><p>ID用于设置MTA0为上传请求的地址，方便随后使用UPLOAD命令。</p><h4 id="0x02-SET-MTA-M"><a href="#0x02-SET-MTA-M" class="headerlink" title="0x02: SET_MTA(M)"></a>0x02: SET_MTA(M)</h4><p><img src="/image/asap/cmd02.png" alt="SET_MTA"></p><p>设置MTA的地址，地址=32bit地址+扩展。</p><p>MTA0用于DOWNLOAD、UPLOAD、DNLOAD_6、SELECT_CAL_PAGE、CLEAR_MEMORY、PROGRAM、PROGRAM_6、MOVE。</p><p>MTA1用于MOVE。</p><h4 id="0x03-DOWNLOAD-M"><a href="#0x03-DOWNLOAD-M" class="headerlink" title="0x03: DOWNLOAD(M)"></a>0x03: DOWNLOAD(M)</h4><p><img src="/image/asap/cmd03.png" alt="DOWNLOAD"></p><p>包含的指定长度(大小)的数据块将被复制到设备的内存，从当前内存传输地址0(MTA0)开始。MTA0指针将会后加Size值。</p><h4 id="0x04-UPLOAD-M"><a href="#0x04-UPLOAD-M" class="headerlink" title="0x04: UPLOAD(M)"></a>0x04: UPLOAD(M)</h4><p><img src="/image/asap/cmd04.png" alt="UPLOAD"></p><p>包含的指定长度(大小)的数据块将被上传到标定软件，从当前内存传输地址0(MTA0)开始。MTA0指针将会后加Size值。</p><h4 id="0x14-GET-DAQ-SIZE-M"><a href="#0x14-GET-DAQ-SIZE-M" class="headerlink" title="0x14: GET_DAQ_SIZE(M)"></a>0x14: GET_DAQ_SIZE(M)</h4><p><img src="/image/asap/cmd14.png" alt="GET_DAQ_SIZE"></p><p>返回指定的DAQ列表的大小作为可用对象的数量并清除当前列表。如果指定的列表号不是Size=0应该返回。</p><h4 id="0x15-SET-DAQ-PTR-M"><a href="#0x15-SET-DAQ-PTR-M" class="headerlink" title="0x15: SET_DAQ_PTR(M)"></a>0x15: SET_DAQ_PTR(M)</h4><p><img src="/image/asap/cmd15.png" alt="SET_DAQ_PTR"></p><p>初始化DAQ列表指针，以便后续写入DAQ列表.</p><h4 id="0x16-WRITE-DAQ-M"><a href="#0x16-WRITE-DAQ-M" class="headerlink" title="0x16: WRITE_DAQ(M)"></a>0x16: WRITE_DAQ(M)</h4><p><img src="/image/asap/cmd16.png" alt="WRITE_DAQ"></p><p>将一个条目(单个DAQ元素的描述)写入由DAQ列表定义的DAQ列表指针(见SET_DAQ_PTR)。定义了以下DAQ元素的大小:1byte，2bytes (type word)，4字节(type long / Float)。ECU可能不支持每个元素和2或4字节的单独地址扩展元素的大小。兼容ECU的限制是主控设备的责任。限制可以在从设备描述文件(ASAP2)中定义。</p><h4 id="0x06-START-STOP-M"><a href="#0x06-START-STOP-M" class="headerlink" title="0x06: START_STOP(M)"></a>0x06: START_STOP(M)</h4><p><img src="/image/asap/cmd06.png" alt="START_STOP"></p><p>该命令用于启动或停止数据采集或准备同步数据开始指定的DAQ列表。LastODTNum编号指定哪些ODT(从0到此DAQ列表的最后ODT号码)应传送。事件通道号指定有效地确定数据传输时序的通用信号源。</p><h4 id="0x07-DISCONNECT-M"><a href="#0x07-DISCONNECT-M" class="headerlink" title="0x07: DISCONNECT(M)"></a>0x07: DISCONNECT(M)</h4><p><img src="/image/asap/cmd07.png" alt="DISCONNECT"></p><p>断开备用设备的连接。断开可以是暂时的，设置从设备处于“脱机”状态或参数0x01终止校准会话。终止会话将使所有状态信息失效，并重置从保护的地位。临时断开不会停止DAQ消息的传输。</p><h4 id="0x1B-GET-CCP-VER-M"><a href="#0x1B-GET-CCP-VER-M" class="headerlink" title="0x1B: GET_CCP_VER(M)"></a>0x1B: GET_CCP_VER(M)</h4><p><img src="/image/asap/cmd1B.png" alt="GET_CCP_VER"></p><p>此命令用于对协议版本进行相互识别主设备和从设备在通用协议版本上达成一致。这命令的执行时间应该在EXCHANGE_ID命令之前。</p><h3 id="可选支持指令"><a href="#可选支持指令" class="headerlink" title="可选支持指令"></a>可选支持指令</h3><h4 id="0x12-GET-SEED-O"><a href="#0x12-GET-SEED-O" class="headerlink" title="0x12: GET_SEED(O)"></a>0x12: GET_SEED(O)</h4><p><img src="/image/asap/cmd12.png" alt="GET_SEED"></p><p>用于解锁设备时获取种子。</p><h4 id="0x13-UNLOCK-O"><a href="#0x13-UNLOCK-O" class="headerlink" title="0x13: UNLOCK(O)"></a>0x13: UNLOCK(O)</h4><p><img src="/image/asap/cmd13.png" alt="UNLOCK"></p><p>发送生成的密钥解锁设备。</p><h4 id="0x23-DOWNLOAD6-O"><a href="#0x23-DOWNLOAD6-O" class="headerlink" title="0x23: DOWNLOAD6(O)"></a>0x23: DOWNLOAD6(O)</h4><p><img src="/image/asap/cmd23.png" alt="DOWNLOAD6"></p><p>包含的固定长度(6字节)的数据将被复制到设备的内存，从当前内存传输地址0(MTA0)开始。MTA0指针将会后加6。</p><h4 id="0x0F-SHORT-UP-O"><a href="#0x0F-SHORT-UP-O" class="headerlink" title="0x0F: SHORT_UP(O)"></a>0x0F: SHORT_UP(O)</h4><p><img src="/image/asap/cmd0F.png" alt="SHORT_UP"></p><p>指定长度(大小)的数据块，从源地址开始将被复制到对应的DTO数据字段。MTA0指针保持不变。</p><h4 id="0x11-SELECT-CAL-PAGE-O"><a href="#0x11-SELECT-CAL-PAGE-O" class="headerlink" title="0x11: SELECT_CAL_PAGE(O)"></a>0x11: SELECT_CAL_PAGE(O)</h4><p><img src="/image/asap/cmd11.png" alt="SELECT_CAL_PAGE"></p><p>该命令的功能依赖于ECU的实现。之前初始MTA0指向选定为当前活动的校准数据页的起点通过这个命令分页。</p><h4 id="0x0C-SET-S-STATUS-O"><a href="#0x0C-SET-S-STATUS-O" class="headerlink" title="0x0C: SET_S_STATUS(O)"></a>0x0C: SET_S_STATUS(O)</h4><p><img src="/image/asap/cmd0C.png" alt="SET_S_STATUS"></p><p>设置从节点了解校准会话的当前状态。</p><h4 id="0x0D-GET-S-STATUS-O"><a href="#0x0D-GET-S-STATUS-O" class="headerlink" title="0x0D: GET_S_STATUS(O)"></a>0x0D: GET_S_STATUS(O)</h4><p><img src="/image/asap/cmd0D.png" alt="GET_S_STATUS"></p><p>获取从节点了解校准会话的当前状态。</p><h4 id="0x0E-BUILD-CHKSUM-O"><a href="#0x0E-BUILD-CHKSUM-O" class="headerlink" title="0x0E: BUILD_CHKSUM(O)"></a>0x0E: BUILD_CHKSUM(O)</h4><p><img src="/image/asap/cmd0E.png" alt="BUILD_CHKSUM"></p><p>返回由MTA0定义的内存块的校验和结果(内存传输区域起始地址)和块大小。校验和算法可能是制造商和/或项目具体，它不是本规范的一部分。</p><h4 id="0x10-CLEAR-MEMORY-O"><a href="#0x10-CLEAR-MEMORY-O" class="headerlink" title="0x10: CLEAR_MEMORY(O)"></a>0x10: CLEAR_MEMORY(O)</h4><p><img src="/image/asap/cmd10.png" alt="CLEAR_MEMORY"></p><p>此命令可用于在重编程前擦除FLASH EPROM。的MTA0指针指向要擦除的内存位置。</p><h4 id="0x18-PROGRAM-O"><a href="#0x18-PROGRAM-O" class="headerlink" title="0x18: PROGRAM(O)"></a>0x18: PROGRAM(O)</h4><p><img src="/image/asap/cmd18.png" alt="PROGRAM"></p><p>指定长度(大小)的数据块将被编程成非易失性存储器(FLASH, EEPROM)，从当前MTA0开始。MTA0指针将会后加Size值。</p><h4 id="0x22-PROGRAM6-O"><a href="#0x22-PROGRAM6-O" class="headerlink" title="0x22: PROGRAM6(O)"></a>0x22: PROGRAM6(O)</h4><p><img src="/image/asap/cmd22.png" alt="PROGRAM6"></p><p>国定长度(6字节)的数据块将被编程成非易失性存储器(FLASH, EEPROM)，从当前MTA0开始。MTA0指针将会后加Size值。</p><h4 id="0x19-MOVE-O"><a href="#0x19-MOVE-O" class="headerlink" title="0x19: MOVE(O)"></a>0x19: MOVE(O)</h4><p><img src="/image/asap/cmd19.png" alt="MOVE"></p><p>指定长度(大小)的数据块将从MTA 0定义的地址复制(源指针)指向MTA 1定义的地址(目的指针)。</p><h4 id="0x20-DIAG-SERVICE-O"><a href="#0x20-DIAG-SERVICE-O" class="headerlink" title="0x20: DIAG_SERVICE(O)"></a>0x20: DIAG_SERVICE(O)</h4><p><img src="/image/asap/cmd20.png" alt="DIAG_SERVICE"></p><p>从设备执行请求的服务，并自动设置内存传输地址MTA0到CCP主设备(主机)可能来自的位置随后上传所请求的诊断服务返回信息。</p><h4 id="0x21-ACTION-SERVICE-O"><a href="#0x21-ACTION-SERVICE-O" class="headerlink" title="0x21: ACTION_SERVICE(O)"></a>0x21: ACTION_SERVICE(O)</h4><p><img src="/image/asap/cmd21.png" alt="ACTION_SERVICE"></p><p>从设备执行请求的服务，并自动设置内存传输地址MTA0到CCP主设备的位置随后上传所请求的操作服务返回信息(如果适用)。</p><h4 id="0x05-TEST-O"><a href="#0x05-TEST-O" class="headerlink" title="0x05: TEST(O)"></a>0x05: TEST(O)</h4><p><img src="/image/asap/cmd05.png" alt="TEST"></p><p>该命令用于测试指定站点地址的从站是否存在可供CCP沟通。此命令不建立逻辑连接，也不会在指定的从站中触发任何活动。站地址(Station)指定为小端字节顺序的数字(Intel格式)。</p><h4 id="0x08-START-STOP-ALL-O"><a href="#0x08-START-STOP-ALL-O" class="headerlink" title="0x08: START_STOP_ALL(O)"></a>0x08: START_STOP_ALL(O)</h4><p><img src="/image/asap/cmd08.png" alt="START_STOP_ALL"></p><p>该命令用于启动所有DAQ列表的周期传输使用之前发送START_STOP命令(启动/停止方式= 2)以同步方式作为“准备开始”。该命令用于停止所有DAQ列表(包括未启动的)的定期传输同步。</p><h4 id="0x09-GET-ACTIVE-CAL-O"><a href="#0x09-GET-ACTIVE-CAL-O" class="headerlink" title="0x09: GET_ACTIVE_CAL(O)"></a>0x09: GET_ACTIVE_CAL(O)</h4><p><img src="/image/asap/cmd09.png" alt="GET_ACTIVE_CAL"></p><p>控件中当前活动的校准页的起始地址从设备。</p><h3 id="Command-Return-Codes"><a href="#Command-Return-Codes" class="headerlink" title="Command Return Codes"></a>Command Return Codes</h3><p><img src="/image/asap/returncode.png" alt="Command Return Codes"></p><h2 id="ASAP2文件规则"><a href="#ASAP2文件规则" class="headerlink" title="ASAP2文件规则"></a>ASAP2文件规则</h2><p>该部分后续完善…</p>]]></content>
      
      
      <categories>
          
          <category> protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标定 </tag>
            
            <tag> 汽车控制器 </tag>
            
            <tag> CCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建Samba服务</title>
      <link href="/tools/zi-jian-samba-fu-wu/"/>
      <url>/tools/zi-jian-samba-fu-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在现在的家庭局域网中，已经有多台联网设备了，设备之间可能需要传输一些文件共享，大部分情况我们都是使用微信等聊天工具进行共享。操作不太方便。因此有了自建一个轻量的网盘服务，在家庭中使用。<br>了解了一下，我们的Mac、Windows、Linux都支持Samba服务。而且Mac、Windows不需要任何额外的软件支持，加上老旧电脑闲置，不再购买NAS设备。而且Samba操作还是很简单的。</p><h2 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>这一步将我旧电脑安装成Linux设备。Linux稳定好用。可以安装桌面版和服务器版。桌面版有图形操作、服务器版没有图形操作，根据自己爱好安装。也可以安装其他Linux操作系统。当然也可以Mac、Windows，可以自己折腾。<br>这里我使用Ubuntu服务器版，以下教程使用Ubuntu。安装步骤按照网上做，教程多。</p><h2 id="安装配置Samba服务"><a href="#安装配置Samba服务" class="headerlink" title="安装配置Samba服务"></a>安装配置Samba服务</h2><ol><li>安装samba服务器。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> samba samba-common<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>创建一个共享文件夹，用于共享使用。这里我们需要给读写执行权限，防止后面在这个文件夹下不能读写执行的操作。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkdir</span> /home/fzxhub/share<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">777</span> /home/fzxhub/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>添加samba用户及密码，后面连接该服务需要提供用户名和密码。该指令后会提示输入密码即可。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> smbpasswd -a 输入需要增加的用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>修改samba的配置文件，该配置文件配置samba的工作模式等等。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/samba/smb.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>share<span class="token punctuation">]</span>comment <span class="token operator">=</span> share folderbrowseable <span class="token operator">=</span> <span class="token function">yes</span>path <span class="token operator">=</span> /home/fzxhub/share   <span class="token comment">#你共享文件夹路径</span>create mask <span class="token operator">=</span> 0700directory mask <span class="token operator">=</span> 0700valid <span class="token function">users</span> <span class="token operator">=</span> fzxhub     force user <span class="token operator">=</span> fzxhubforce group <span class="token operator">=</span> fzxhubpublic <span class="token operator">=</span> <span class="token function">yes</span>available <span class="token operator">=</span> <span class="token function">yes</span>writable <span class="token operator">=</span> <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>重启Samba服务器</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">service</span> smbd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>查询服务器端的IP地址，该IP地址后续连接需要，建议静态IP，防止该服务器的IP地址变更后不能访问问题。可以在Ubuntu上设置为静态IP，也可以在我们的路由器上将IP地址和MAC地址绑定后来固定IP地址。</li></ol><h2 id="其他局域网设备连接Samba服务"><a href="#其他局域网设备连接Samba服务" class="headerlink" title="其他局域网设备连接Samba服务"></a>其他局域网设备连接Samba服务</h2><h3 id="Mac连接Samba服务"><a href="#Mac连接Samba服务" class="headerlink" title="Mac连接Samba服务"></a>Mac连接Samba服务</h3><p>在Mac的网络中即可发现服务器的名称，点击名称后，再点击连接身份输入，输入我们在Samba服务设置的用户名和密码后就连接好了。</p><h3 id="IOS连接Samba服务"><a href="#IOS连接Samba服务" class="headerlink" title="IOS连接Samba服务"></a>IOS连接Samba服务</h3><p>在IOS设备的文件APP中，IOS设备Apple官方的APP。右上角选择连接服务器输入”smb://IP地址”，选择注册用户，然后输入用户名和密码即可连接。</p><h3 id="Windows连接Samba服务"><a href="#Windows连接Samba服务" class="headerlink" title="Windows连接Samba服务"></a>Windows连接Samba服务</h3><p>在Windows的运行或者资源管理器的路径栏输入”\\IP地址”，即可访问，然后在文件夹上右键选择映射网络驱动器即可加入盘符访问，如需要输入用户名和密码输入即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eMIOS模块的介绍</title>
      <link href="/mcu/emios-mo-kuai-de-jie-shao/"/>
      <url>/mcu/emios-mo-kuai-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>eMIOS(Enhanced Modular IO Subsystem)增强型模块化IO子系统，在多种控制器的外设模块中存在，本次来了解eMIOS的原理。助力开发中更好使用它。<br>本次介绍主要资料来源NXP S32K3的相关手册。该手册介绍的比较详细，更加方便我们了解eMIOS的原理，原理会了，在其他MCU中使用大同小异。</p><h2 id="eMIOS模块说明"><a href="#eMIOS模块说明" class="headerlink" title="eMIOS模块说明"></a>eMIOS模块说明</h2><h3 id="组成说明"><a href="#组成说明" class="headerlink" title="组成说明"></a>组成说明</h3><p>每个eMIOS模块都有24或者更多个通道（UC），这些通道都是相互独立的且又是互相配合，但是这些通道在结构上并不是一模一样，基本以8个通道为一组，多组通道组成一个eMIOS模块。具体差异可以参考手册。这里主要原理说明。</p><p><img src="/image/emios/BD.png" alt="模块"></p><h3 id="时钟源、计数器说明"><a href="#时钟源、计数器说明" class="headerlink" title="时钟源、计数器说明"></a>时钟源、计数器说明</h3><p>每个eMIOS的每个通道都有自己的计数源（Counter Bus或者叫CNT）也叫该通道的内部计数器，在eMIOS模块的时钟源驱动下进行计数。</p><p>部分的eMIOS通道可以将自己内部的计数器分享出去共给其他通道使用，这样就可以做到计数器同步来做一些高级的应用。在实际使用时，根据应用、功能需求等选择使用哪个计数器作为该通道的计数器来工作。例如产生单个PWM使用内部计数器即可；产生步进电机的驱动脉冲则使用Counter Bus B/C/D/E可完成多个通道波形产生来控制可解决波形同步问题。</p><p><img src="/image/emios/CB.png" alt="模块"></p><p>例如S32K3的eMIOS中，Counter Bus A是一个全局的计数器，它是由CH23产生分享的，可以给任何通道使用；Counter Bus B是一个局部的计数器，它是由CH0产生分享的，可以给1-7任何通道使用；Counter Bus C是一个局部的计数器，它是由CH8产生分享的，可以给9-15任何通道使用；Counter Bus D是一个局部的计数器，它是由CH16产生分享的，可以给17-22任何通道使用；Counter Bus F同理Counter Bus A，是由CH22分享产生的。</p><p><img src="/image/emios/UC.png" alt="通道"></p><p>例如S32K3的eMIOS的一个通道的内部框图如上。计数器来源可以来源Counter Bus A、Counter Bus B/C/D/E、Counter Bus F。</p><h2 id="eMIOS-SAIC模式"><a href="#eMIOS-SAIC模式" class="headerlink" title="eMIOS SAIC模式"></a>eMIOS SAIC模式</h2><p>Single Action Input Capture  Mode 就是输入捕获，检测到一个上升沿或者下降沿，UC就生成一个Flag信号，同时捕捉当前Counter Bus的值到AS2。也可以上升沿和下降沿同时采集。</p><p><img src="/image/emios/SAIC.png" alt="SAIC"><br><img src="/image/emios/SAICB.png" alt="SAICB"></p><h2 id="eMIOS-SAOC模式"><a href="#eMIOS-SAOC模式" class="headerlink" title="eMIOS SAOC模式"></a>eMIOS SAOC模式</h2><p>Single Action Output Capture  Mode就是输出匹配模式。给AS2写入一个值后，当Counter Bus的值与AS2相等时，这个时候就会产生一个Flag信号，同时控制输出跳变或者翻转。</p><p><img src="/image/emios/SAOC.png" alt="SAOC"><br><img src="/image/emios/SAOCT.png" alt="SAOCT"></p><h2 id="eMIOS-IPWM模式"><a href="#eMIOS-IPWM模式" class="headerlink" title="eMIOS IPWM模式"></a>eMIOS IPWM模式</h2><p>Input Pulse Width Measurement Mode，这个模式就是用来测量两个连续不同沿之间的宽度，即测量一个电平宽度。当检测到第一个沿，捕捉Counter Bus的值存入AS2，当检测到第二个沿，再捕捉Counter Bus的值存入BS2并产生一个Flag信号。第一个边沿为上升沿第二个边沿为下降沿表示测量高电平宽度；第一个边沿为下升沿第二个边沿为上降沿表示测量低电平宽度。</p><p><img src="/image/emios/IPWM.png" alt="IPWM"></p><h2 id="eMIOS-IPM模式"><a href="#eMIOS-IPM模式" class="headerlink" title="eMIOS IPM模式"></a>eMIOS IPM模式</h2><p>Input Period Measurement Mode，这个模式用来测量两个连续相同沿的宽度，和 IPWM类似。测量的是信号周期，即检测到第一个沿（上升沿或者下降沿），捕捉Counter Bus的值存入AS2，当检测到第二个沿（与第一个沿相同），再捕捉Counter Bus的值存入BS2并产生一个Flag信号。</p><p><img src="/image/emios/IPM.png" alt="IPM"></p><h2 id="eMIOS-DAOC模式"><a href="#eMIOS-DAOC模式" class="headerlink" title="eMIOS DAOC模式"></a>eMIOS DAOC模式</h2><p>Double Action Output Compare Mode，这个模式相比较SAOC，它有两个比较输出，就是当第一个匹配事件发生时，将输出信号翻转，第二个匹配事件发生时，将输出信号再次翻转。第一个事件匹配成功后可生产Flag信号也可以不生成Flag信号（可设置），而第二个匹配成功后则产生Flag信号。</p><p><img src="/image/emios/DAOC.png" alt="DAOC"></p><h2 id="eMIOS-PEC模式"><a href="#eMIOS-PEC模式" class="headerlink" title="eMIOS PEC模式"></a>eMIOS PEC模式</h2><p>Pulse Edge Counting Mode，可测量信号的脉冲数或者边沿数。外部信号输入检测到有效信号后计数器累加，并且在当计数器CNT值发生匹配事件AS1后，复位计数器CNT并启动计数，发生匹配事件BS1后，停止计数并且输出Flag信号。</p><p><img src="/image/emios/PEC.png" alt="PEC"></p><h2 id="更多模式介绍后续完善…"><a href="#更多模式介绍后续完善…" class="headerlink" title="更多模式介绍后续完善…"></a>更多模式介绍后续完善…</h2>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eMIOS </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootLoader开发介绍</title>
      <link href="/mcu/bootloader-kai-fa-jian-jie/"/>
      <url>/mcu/bootloader-kai-fa-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="该文档结构说明"><a href="#该文档结构说明" class="headerlink" title="该文档结构说明"></a>该文档结构说明</h2><ol><li>BootLoader的介绍</li><li>介绍BootLoader的整体功能与模块（通信、NVM驱动、存储管理、跳转管理模块）</li><li>以NXP的S32系列的一款MCU举例BootLoader的开发</li></ol><h2 id="BootLoader介绍"><a href="#BootLoader介绍" class="headerlink" title="BootLoader介绍"></a>BootLoader介绍</h2><p>BootLoader就是驻留MCU非易失性存储器中的一段程序加载代码，每次复位后，都会运行Boot。它会检查是否有来自通信总线的远程程序加载请求，如果有则进入BootLoader模式，建立与程序下载端(通常为PC上位机)的总线通信并接收通信总线下载的应用程序、解析其地址和数据代码，运行NVM（None Valitale Momory-非易失性存储器）驱动程序，将其编程到NVM（一般为Flash）中，并校验其完整性，从而完成应用程序更新。如果没有来自通信总线的远程程序加载请求，则直接跳转到应用程序复位入口函数（复位中断ISR），运行APP（应用程序）。</p><p><img src="/image/boot/First.png" alt="RUN"></p><p>本文介绍的BootLoader属于MCU层面的BootLoader，不同与U-Boot那样强大的功能，BootLoader的主要功能：</p><ol><li>通信模块：与远程程序下载端建立可靠的总线通信以获取要更新应用程序；</li><li>NVM驱动模块：NVM驱动将应用程序的代码和数据编程到NVM中并校验；</li><li>存储管理：需要根据MCU的RAM和ROM大小、Boot和应用的需求来进行存储的合理规划；</li><li>跳转管理：根据跳转条件跳转到应用程序处执行应用代码，或者从应用代码跳回Boot进行升级操作。</li></ol><h2 id="通信模块"><a href="#通信模块" class="headerlink" title="通信模块"></a>通信模块</h2><p>通信模块主要作用是建立程序下载端与MCU端的通信联系通道，可以进行握手、数据发送、数据接收等。</p><ol><li>总线的选择：总线通信可选择UART、SPI、USB、CAN、LIN、以太网。只具体需要用到某种通信总线取决于实际应用，在汽车领域一般选择CAN。</li><li>总线驱动：在bootloader中必须开发相应的通信总线外设驱动程序，实现基本的数据发送和接收功能。</li><li>通信的可靠性：为了保证通信的可靠性，必须开发一个基于通信总线完善的通信协议，应用程序下载端和bootloader之间需要建立请求命令、确认、等待、错误重传、数据打包、数据解包等机制。bootloader根据不同的请求命令完成不同的任务并确认操作是否完成(ACK)以及数据是否正被确完整的传输，若出现数据错误(通过校验和或者ECC实现)，需要进行自动重传。汽车领域一般需要实现CAN_UDS或者CAN_CPP协议栈来处理通信。</li><li>通信下载端：通过在PC上开发GUI软件，实现要求的总线通信协议，一般在其底层都是通过调用相应的总线设备，如USB转CAN/LIN的转发器设备的动态库(DLL)的API接口来实现数据的收发，相应的总线USB转发设备都会提供相应的驱动库(DLL)。因此bootloader开发者一般还需具备一定的PC上位机软件开发能力。</li></ol><h2 id="NVM驱动模块"><a href="#NVM驱动模块" class="headerlink" title="NVM驱动模块"></a>NVM驱动模块</h2><p>NVM（None Valitale Momory-非易失性存储器）一般包括其MCU片内集成的用于存放数据的EEPROM或者Data-Flash和用于存储程序代码/数据的Code-Flash/Program-Flash以及MPU扩展的片外NOR Flash或者NAND-Flash；NVM驱动程序包括对NVM的擦除(erase)、编程(program)和校验(verify)等基本操作，也包括对NVM的加密(secure)/解密(unsecure)和加保护(protection)/解保护(unprotection)操作。</p><ol><li>工作速度：由于NVM的工作速度一般较CPU内核频率和总线频率低，所以运行NVM驱动前必须对NVM进行初始化，将设置分频器其工作频率设置为正常工作所需频率范围。</li><li>总线竞争：MCU片内的NVM同一个block上不能运行NVM的驱动对其自身进行擦除和编程操作，否则会传出read while write的总线访问冲突（每个NVM block只有一条数据总线，一个时刻只能进行读出或者写入，不支持同时读出和写入）。另一个方案是可以将NVM驱动拷贝到MCU的RAM中运行。</li><li>驱动存储位置：NVM的驱动程序驻留在NVM中，如果出现堆栈溢出等意外程序跑飞意外运行NVM驱动程序则会造成NVM内容意外擦除丢失或者修改的情况。因此需要对关键数据或代码（比如bootloader本身）进行保护以防止意外修改，或者更为安全的方法是不将NVM驱动程序存放在NVM中，而是在bootloader最开始通过上位机将其下载到RAM中运行，bootloader结束后将该区域RAM清除，从而避免由于意外运行NVM驱动程序造成的NVM数据丢失和修改。</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="MCU执行程序原理"><a href="#MCU执行程序原理" class="headerlink" title="MCU执行程序原理"></a>MCU执行程序原理</h3><p>MCU内部闪存(FLASH)地址有一个起始地址，一般情况下，程序文件就从此地址开始写入。程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，而这张“中断向量表”的起始地址是FLASH的起始地址加4字节处，也是复位中断向量的地址。当中断来临，MCU内部硬件机制亦会自动将 PC指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行中断服务程序。</p><p><img src="/image/boot/RUN1.jpeg" alt="RUN"></p><p>如图，MCU复位后，先从 0X08000004 地址取出复位中断向量的地址，并跳转到复位中断服务序，如图标号1所示，在复位中断服务程序执行完之后，会跳转到我们 的 main 函数，如图标号2所示，而我们的 main 函数一般都是一个死循环，在 main 函数执行过 程中，如果收到中断请求(发生重中断)，此时 CPU强制将PC指针指回中断向量表处，如图标号3所示;然后，根据中断源进入相应的中断服务程序，如图标号4所示;在执行完中 断服务程序以后，程序再次返回 main 函数执行，如图标号5所示。</p><h3 id="ROM、RAM的空间划分"><a href="#ROM、RAM的空间划分" class="headerlink" title="ROM、RAM的空间划分"></a>ROM、RAM的空间划分</h3><p><img src="/image/boot/ROM.jpg" alt="ROM"></p><p>Boot和应用程序的链接文件中，对NVM的地址空间分配必须分开独立，不能重叠(overlap)，但其RAM分配没有约束，两者都可以使用整个RAM空间，因为跳转到应用工程后，将启动代码将重新初始化RAM；</p><p>根据升级需求，我们需要将ROM分区处理，一部分存放Boot代码，一部分存放APP的代码。APP存放方案有两种，方案一是APP只有一份在ROM中，升级前需要将APP区域擦除后才能写入新的APP代码。方案二是APP有两份在ROM中，当前有效的APP不用擦除就可以下载新的APP代码。</p><h4 id="方案一优缺点"><a href="#方案一优缺点" class="headerlink" title="方案一优缺点"></a>方案一优缺点</h4><ol><li>ROM空间利用率高；</li><li>如果新的APP升级失败，则不能启动APP，只能留在Boot中。</li></ol><h4 id="方案二优缺点"><a href="#方案二优缺点" class="headerlink" title="方案二优缺点"></a>方案二优缺点</h4><ol><li>ROM空间利用率低；</li><li>如果新的APP升级失败，可以留在旧的APP中，不影响之前的功能。</li></ol><h2 id="跳转管理"><a href="#跳转管理" class="headerlink" title="跳转管理"></a>跳转管理</h2><p>bootloader和应用程序分别是两个完整的MCU软件工程，各自都由自己的启动代码、main()函数、链接文件、外设驱动程序和中断向量表。</p><h3 id="Boot到应用程序的跳转方法"><a href="#Boot到应用程序的跳转方法" class="headerlink" title="Boot到应用程序的跳转方法"></a>Boot到应用程序的跳转方法</h3><p>开发使用bootloader后，每次MCU复位之后都将首先运行Boot，若符合运行APP的条件则直接跳转到应用程序复位函数地址。找到应用程序复位函数地址的方案有两种：</p><ol><li>通过链接文件固定应用程序的复位启动函数地址</li><li>从应用程序中断向量表的复位向量地址获取</li></ol><h3 id="Boot跳转到APP"><a href="#Boot跳转到APP" class="headerlink" title="Boot跳转到APP"></a>Boot跳转到APP</h3><p>Boot更新完应用程序并校验其完整性OK之后，将用到的外设(比如CAN/LIN通信总线模块、定时器、GPIO等)寄存器恢复到复位后的默认状态，然后根据APP的复位函数地址跳转。</p><h3 id="APP跳转到Boot"><a href="#APP跳转到Boot" class="headerlink" title="APP跳转到Boot"></a>APP跳转到Boot</h3><p>在APP运行时需要跳回Boot时，可以使用软件复位即可回到Boot。</p><h2 id="S32为例BootLoader开发"><a href="#S32为例BootLoader开发" class="headerlink" title="S32为例BootLoader开发"></a>S32为例BootLoader开发</h2><h3 id="RAM、Flash的需求分析以及分区规划"><a href="#RAM、Flash的需求分析以及分区规划" class="headerlink" title="RAM、Flash的需求分析以及分区规划"></a>RAM、Flash的需求分析以及分区规划</h3><ol><li>找出MCU的内存分布图/表，找到Flash、RAM的起始地址、结束地址。</li></ol><p><img src="/image/boot/S32Memory.png" alt="S32Memory"></p><ol start="2"><li>根据需求画出Flash、RAM的分区逻辑图（S32的Flash最小擦除单位4K）</li></ol><p><img src="/image/boot/S32Memmap.jpg" alt="S32Memmap"></p><h3 id="Boot项目RAM、Flash分区"><a href="#Boot项目RAM、Flash分区" class="headerlink" title="Boot项目RAM、Flash分区"></a>Boot项目RAM、Flash分区</h3><ol><li>Boot项目链接脚本的修改，划出我们需要的分区</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">MEMORY<span class="token punctuation">&#123;</span>  <span class="token comment">/* Flash ALL = 128K*/</span>  <span class="token function">m_interrupts</span>          <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000400</span>  <span class="token comment">//1K</span>  <span class="token function">m_flash_config</span>        <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00000400</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000010</span>  <span class="token comment">//16Byte</span>  <span class="token function">m_text</span>                <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00000410</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x0001FBF0</span>  <span class="token comment">//~=127K</span>  <span class="token comment">/* SRAM_L ALL = 64K*/</span>      <span class="token function">share_noinit</span>          <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x1FFF0000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000400</span> <span class="token comment">//Add sections 1K</span>  <span class="token function">flashDrv</span>              <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x1FFF0400</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000400</span> <span class="token comment">//Add sections 1K</span>  <span class="token function">m_data</span>                <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x1FFF0800</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x000F8000</span> <span class="token comment">//62K</span>  <span class="token comment">/* SRAM_U ALL = 60K*/</span>  <span class="token function">m_data_2</span>              <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x20000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x0000F000</span> <span class="token comment">//60K</span><span class="token punctuation">&#125;</span>SECTIONS<span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token function">share_noinit</span> <span class="token punctuation">(</span>NOLOAD<span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">KEEP</span><span class="token punctuation">(</span><span class="token operator">*</span>BootMange<span class="token punctuation">.</span><span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">.</span>share_noinit<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">KEEP</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>share_noinit<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token operator">></span> share_noinit<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Startup文件修改，增加了新的分区，在复位的时候需要进行清除操作来同步ECC的校验数据，防止ECC的报错。但是share_noinit段只能在硬件复位情况下才进行清除，因为share_noinit我们的用途是用来做BOOT和APP之间的交互使用。在APP跳到BOOT的时候（软件复位）不能清除share_noinit段。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Clear the flash driver data section */</span><span class="token keyword">while</span><span class="token punctuation">(</span>flashDrv_end <span class="token operator">!=</span> flashDrv_start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>flashDrv_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    flashDrv_start<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* Clear Noinit section when Power-On Reset in order to initialize the ECC detection hardware */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">McuIsPowerOnReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>share_noinit_end <span class="token operator">!=</span> share_noinit_start<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>share_noinit_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        share_noinit_start<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="APP项目RAM、Flash分区"><a href="#APP项目RAM、Flash分区" class="headerlink" title="APP项目RAM、Flash分区"></a>APP项目RAM、Flash分区</h3><ol><li>APP项目链接脚本的修改，划出我们需要的分区，share_noinit段因为和Boot共享所以必须同地址同长度。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">MEMORY<span class="token punctuation">&#123;</span>  <span class="token comment">/* Flash  ALL = 896K*/</span>  <span class="token function">CAL</span>   <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00020000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00001000</span>  <span class="token comment">//Add sections 4K</span>  <span class="token function">m_interrupts</span>          <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00021000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000400</span> <span class="token comment">//1K</span>  <span class="token function">m_flash_config</span>        <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00021400</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000010</span> <span class="token comment">//16byte</span>  <span class="token function">m_text</span>                <span class="token punctuation">(</span>RX<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00021410</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x000DEBF0</span> <span class="token comment">//~=891K</span>  <span class="token comment">/* SRAM_L ALL = 64K*/</span>  <span class="token function">share_noinit</span>          <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x1FFF0000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x00000400</span> <span class="token comment">//Add sections 1K</span>  <span class="token function">m_data</span>                <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x1FFF0400</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x0000FC00</span> <span class="token comment">//63K </span>  <span class="token comment">/* SRAM_U ALL = 60K*/</span>  <span class="token function">m_data_2</span>              <span class="token punctuation">(</span>RW<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x20000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">0x0000F000</span> <span class="token comment">//60K</span><span class="token punctuation">&#125;</span>SECTIONS<span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token function">share_noinit</span> <span class="token punctuation">(</span>NOLOAD<span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">KEEP</span><span class="token punctuation">(</span><span class="token operator">*</span>BootMange<span class="token punctuation">.</span><span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">.</span>share_noinit<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">KEEP</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>share_noinit<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token operator">></span> share_noinit        <span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token function">ORIGIN</span><span class="token punctuation">(</span>CAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span>cal <span class="token operator">:</span>    <span class="token punctuation">&#123;</span>        <span class="token function">KEEP</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>cal<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token operator">></span> CAL<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="跳转处理"><a href="#跳转处理" class="headerlink" title="跳转处理"></a>跳转处理</h3><ol><li>在从APP跳到BOOT时需要做Stay in Boot的标志作用，预先分区了share_noinit段，因此我们在跳转处理时进行标志的变量需要放到share_noinit段。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  uint8 JumpType<span class="token punctuation">;</span>  uint8 JumpType_Lv<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> TypeOfJump_t<span class="token punctuation">;</span><span class="token comment">//定义方法1：</span><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token string">".share_noinit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> TypeOfJump_t <span class="token punctuation">;</span><span class="token comment">//定义方法2：</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">section </span><span class="token string">".share_noinit"</span></span>TypeOfJump_t TypeOfJump<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">section</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>根据链接脚本定义，我们知道了APP的分区开始，就知道了APP的复位中断函数的地址，将这个地址强转化为函数指针后，跳到该地址执行该函数，就跳到了APP的代码执行了。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BOOT_CheckIsNeedJump</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">static</span> uint32 JumpAddress<span class="token punctuation">;</span>uint8 temp <span class="token operator">=</span> <span class="token operator">~</span>TypeOfJump<span class="token punctuation">.</span>JumpType_Lv<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>TypeOfJump<span class="token punctuation">.</span>JumpType <span class="token operator">==</span> temp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>TypeOfJump<span class="token punctuation">.</span>JumpType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> BOOT_JUMP_APP<span class="token operator">:</span><span class="token function">Boot_SetTypeOfJump</span><span class="token punctuation">(</span>NO_NEED_JUMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JumpAddress <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint32 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FLASH_APP_START_ADDRESS <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>JumpFunction_t<span class="token punctuation">)</span>JumpAddress<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> APP_JUMP_BOOT<span class="token operator">:</span><span class="token function">Boot_SetTypeOfJump</span><span class="token punctuation">(</span>NO_NEED_JUMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BOOT_StayInBoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DS_SetReprogPattenValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> BOOT_JUMP_EOL<span class="token operator">:</span><span class="token function">Boot_SetTypeOfJump</span><span class="token punctuation">(</span>NO_NEED_JUMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JumpAddress <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint32 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FLASH_EOL_START_ADDRESS <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>JumpFunction_t<span class="token punctuation">)</span>JumpAddress<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token function">Boot_SetTypeOfJump</span><span class="token punctuation">(</span>NO_NEED_JUMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">/* Power On */</span><span class="token function">Boot_SetTypeOfJump</span><span class="token punctuation">(</span>NO_NEED_JUMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Boot与FlashDriver对接"><a href="#Boot与FlashDriver对接" class="headerlink" title="Boot与FlashDriver对接"></a>Boot与FlashDriver对接</h3><ol><li>FlashDriver项目中来编写FlashDriver的实体，为了Boot能调用我们的FlashDriver的实体，我们需要为我们实现的功能建立索引结构体，FlashDriver项目的结构体和Boot的结构体保持一一对应，在Boot中就能调用FlashDriver的功能。</li></ol><ul><li>FlashDriver</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> FingerPrint<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>FlashFun_t flashInitFun<span class="token punctuation">;</span>FlashFun_t flashEraseFun<span class="token punctuation">;</span>FlashFun_t flashWriteFun<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> FlashHeader_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> errorCode<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span>  address<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span>  length<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token class-name">flash_ssd_config_t</span><span class="token operator">*</span> flashSSDConfig<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> FlashParam_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> FlashFun_t<span class="token punctuation">)</span><span class="token punctuation">(</span> FlashParam_t <span class="token operator">*</span>flashParam <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//FlashDriver项目中索引结构体，放在FlashDriver分区的头部方便在Boot中索引</span><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token string">".flashDrvHeader"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> FlashHeader_t FlashHeader <span class="token operator">=</span><span class="token punctuation">&#123;</span>FLASH_FINGER_PRINT<span class="token punctuation">,</span><span class="token operator">&amp;</span>FLASHDRV_Init<span class="token punctuation">,</span><span class="token operator">&amp;</span>FLASHDRV_Erase<span class="token punctuation">,</span><span class="token operator">&amp;</span>FLASHDRV_Write<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Boot</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> errorCode<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span>  address<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span>  length<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token class-name">flash_ssd_config_t</span><span class="token operator">*</span> flashSSDConfig<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> FlashParam_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> FlashFun_t<span class="token punctuation">)</span><span class="token punctuation">(</span> FlashParam_t <span class="token operator">*</span>flashParam <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> FingerPrint<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>FlashFun_t flashInitFun<span class="token punctuation">;</span>FlashFun_t flashEraseFun<span class="token punctuation">;</span>FlashFun_t flashWriteFun<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> FlashHeader_t<span class="token punctuation">;</span><span class="token comment">//索引结构体起始地址就是FLASHDRV_START_ADDRESS，从该地址按FlashHeader_t检索则得到FlashDriver的函数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FLASHDRV_ADDRESS</span>                <span class="token expression"><span class="token punctuation">(</span>FLASHDRV_START_ADDRESS<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLASH_DRIVER_VALID</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FlashHeader_t<span class="token operator">*</span><span class="token punctuation">)</span>FLASHDRV_ADDRESS<span class="token punctuation">)</span><span class="token operator">-></span>FingerPrint<span class="token punctuation">,</span> FLASH_FINGER_PRINT<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FlashHeader_t<span class="token operator">*</span><span class="token punctuation">)</span>FLASHDRV_ADDRESS<span class="token punctuation">)</span><span class="token operator">-></span>FingerPrint<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLASH_DRIVER_INIT</span><span class="token expression"><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FlashHeader_t<span class="token operator">*</span><span class="token punctuation">)</span>FLASHDRV_ADDRESS<span class="token punctuation">)</span><span class="token operator">-></span>flashInitFun<span class="token punctuation">)</span><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLASH_DRIVER_ERASE</span><span class="token expression"><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FlashHeader_t<span class="token operator">*</span><span class="token punctuation">)</span>FLASHDRV_ADDRESS<span class="token punctuation">)</span><span class="token operator">-></span>flashEraseFun<span class="token punctuation">)</span><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLASH_DRIVER_WRITE</span><span class="token expression"><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FlashHeader_t<span class="token operator">*</span><span class="token punctuation">)</span>FLASHDRV_ADDRESS<span class="token punctuation">)</span><span class="token operator">-></span>flashWriteFun<span class="token punctuation">)</span><span class="token punctuation">(</span>flashParam<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> BootLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑调试器link-logic</title>
      <link href="/project/luo-ji-diao-shi-qi-link-logic/"/>
      <url>/project/luo-ji-diao-shi-qi-link-logic/</url>
      
        <content type="html"><![CDATA[<h2 id="link-logic"><a href="#link-logic" class="headerlink" title="link_logic"></a>link_logic</h2><p>带link调试功能、串口调试、逻辑分析仪与一身的数字调试器 </p><p>项目地址：<a href="https://github.com/fzxhub/link_logic">GitHub</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本项目是一个link logic，用于调试带SWD接口的单片机、以及带有逻辑分析仪。是一个美观、小巧、功能全的逻辑分析仪调试器。</p><h2 id="实物展示"><a href="#实物展示" class="headerlink" title="实物展示"></a>实物展示</h2><p><img src="/image/logic/1.png" alt="avatar"><br><img src="/image/logic/2.jpg" alt="avatar"><br><img src="/image/logic/4.jpg" alt="avatar"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>小巧、多功能</li><li>插针隐藏设计、方便携带</li><li>支持Link调试器</li><li>支持逻辑分析仪</li><li>支持ESP32等IC的自动下载（RTS、DTR信号预留）</li><li>使用Typec接口的自定义成SWD、UART信号接口</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>link调试器</li><li>USB转UART（CP2102虚拟的串口）</li><li>USB HUB（可以再接入其他1个USB设备，TYPEC接口）</li><li>支持逻辑分析仪功能</li></ol><h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>丝印说明：LC表示逻辑分析仪功能模块、LK表示Link功能模块、CP表示CP2102串口</p><p><img src="/image/logic/3.png" alt="avatar"></p><ol><li>LINK调试器、逻辑分析仪、CP2102串口三大功能，LINK调试器、逻辑分析仪可分别开关操作，防止USB接口电流过大影响功能。</li><li>Link调试器输出电压端可切换3.3V和5.0V，适配供电给不同的单片机</li><li>LC-CH0至LC-CH7为逻辑分析仪的采集端（LINK打开时可用），LC-3V3、LC-5V0同时受LINK开关控制，只有打开时才有电压。</li><li>LK-SCK、LK-SWD、LK-RST、LK-SWO是Link调试器的接口，一般情况只使用LK-SCK、LK-SWD即可</li><li>LK-URX、LK-UTX是Link调试器的串口TTL接口（不同Link的固件可能不支持）</li><li>LK-VCC，是Link调试器的电压输出，电压值由LINK-VCC切换开关控制</li><li>CP-URX、CP-UTX、CP-RTS、CP-DTR是CP2102串口的接口，CP-RTS、CP-DTR可用于类似ESP32的串口自动下载。可参考ESP32官方电路设计。</li><li>所有GND共地</li><li>LINK的typec USB接口有两种连接方式分别表示正插是LINK调试器、反插是串口功能<ul><li>正：DP与SCK连接、DN与SWD连接</li><li>反：DP与UTX连接、DN与URX连接</li></ul></li><li>HUB 的typec USB接口可以接USB设备到PC。也可以使用两个link_logic级联，不建议多级连接，USB性能会下降。</li></ol><p>注意：建议将link_logic直接接在PC的USB口上，不接在其他USB HUB上，因为本设备中已经含有一个USB HUB，多级HUB连接，影响逻辑分析仪的采集性能，逻辑分析仪需要用到USB2.0的高速模式。</p><h2 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h2><ol><li>逻辑分析仪的固件烧录及使用方式参考：<a href="https://github.com/wuxx/nanoDLA">https://github.com/wuxx/nanoDLA</a></li><li>Link逻辑分析仪固件参考：<a href="https://github.com/fzxhub/link_debuger">https://github.com/fzxhub/link_debuger</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> link </tag>
            
            <tag> logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvgl在PC上模拟自己的代码</title>
      <link href="/gui/lvgl-zai-pc-shang-mo-ni-zi-ji-de-dai-ma/"/>
      <url>/gui/lvgl-zai-pc-shang-mo-ni-zi-ji-de-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>使用官方VScode模拟器项目</li><li>使用lvgl8.0代码</li><li>使用macos系统</li><li>也就是我仓库lvgl_sim_vscode前提之下</li></ul><h2 id="建立自己的代码文件"><a href="#建立自己的代码文件" class="headerlink" title="建立自己的代码文件"></a>建立自己的代码文件</h2><ol><li>在lv_examples/src下新建文件夹lv_myapp</li><li>lv_examples/src/lv_myapp新建lv_myapp.c和lv_myapp.h</li></ol><h3 id="lv-myapp-h中代码如下"><a href="#lv-myapp-h中代码如下" class="headerlink" title="lv_myapp.h中代码如下"></a>lv_myapp.h中代码如下</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * @file lv_myapp.h * */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LV_MYAPP_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LV_MYAPP_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/********************* *      INCLUDES *********************/</span><span class="token comment">/********************* *      DEFINES *********************/</span><span class="token comment">/********************** *      TYPEDEFS **********************/</span><span class="token comment">/********************** * GLOBAL PROTOTYPES **********************/</span><span class="token keyword">void</span> <span class="token function">lv_myapp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/********************** *      MACROS **********************/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token punctuation">&#125;</span> <span class="token comment">/* extern "C" */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/*LV_MYAPP_H*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lv-myapp-c中代码如下"><a href="#lv-myapp-c中代码如下" class="headerlink" title="lv_myapp.c中代码如下"></a>lv_myapp.c中代码如下</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../../lv_demo.h"</span></span><span class="token keyword">void</span> <span class="token function">lv_myapp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">lv_obj_t</span> <span class="token operator">*</span>scr <span class="token operator">=</span> <span class="token function">lv_scr_act</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">lv_obj_t</span> <span class="token operator">*</span>label1 <span class="token operator">=</span> <span class="token function">lv_label_create</span><span class="token punctuation">(</span>scr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lv_label_set_text</span><span class="token punctuation">(</span>label1<span class="token punctuation">,</span><span class="token string">"I am fzxhub!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lv_obj_align</span><span class="token punctuation">(</span>label1<span class="token punctuation">,</span>LV_ALIGN_CENTER<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用自己头文件"><a href="#引用自己头文件" class="headerlink" title="引用自己头文件"></a>引用自己头文件</h2><p>在lv_examples/lv_demo.h中添加自己的头文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_demo_widgets/lv_demo_widgets.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_demo_benchmark/lv_demo_benchmark.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_demo_stress/lv_demo_stress.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_demo_keypad_encoder/lv_demo_keypad_encoder.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_demo_music/lv_demo_music.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"src/lv_myapp/lv_myapp.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在main-c中调用自己的代码"><a href="#在main-c中调用自己的代码" class="headerlink" title="在main.c中调用自己的代码"></a>在main.c中调用自己的代码</h2><p>在hal_init();之后调用自己的函数即可，然后运行可查看效果。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  <span class="token comment">/*Initialize LVGL*/</span>  <span class="token function">lv_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*Initialize the HAL (display, input devices, tick) for LVGL*/</span>  <span class="token function">hal_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  lv_example_switch_1();</span><span class="token comment">//  lv_example_calendar_1();</span><span class="token comment">//  lv_example_btnmatrix_2();</span><span class="token comment">//  lv_example_checkbox_1();</span><span class="token comment">//  lv_example_colorwheel_1();</span><span class="token comment">//  lv_example_chart_6();</span><span class="token comment">//  lv_example_table_2();</span><span class="token comment">//  lv_example_scroll_2();</span><span class="token comment">//  lv_example_textarea_1();</span><span class="token comment">//  lv_example_msgbox_1();</span><span class="token comment">//  lv_example_dropdown_2();</span><span class="token comment">//  lv_example_btn_1();</span><span class="token comment">//  lv_example_scroll_1();</span><span class="token comment">//  lv_example_tabview_1();</span><span class="token comment">//  lv_example_tabview_1();</span><span class="token comment">//  lv_example_flex_3();</span><span class="token comment">//  lv_example_label_1();</span><span class="token comment">//  lv_demo_widgets();</span><span class="token comment">//  lv_demo_keypad_encoder();</span><span class="token comment">//  lv_demo_benchmark();</span><span class="token comment">//  lv_demo_stress();</span><span class="token comment">//  lv_demo_music();</span>    <span class="token function">lv_myapp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> gui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lgvl </tag>
            
            <tag> gui </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux和macos搭建esp32的Vscode开发环境</title>
      <link href="/mcu/linux-he-macos-da-jian-esp32-de-vscode-kai-fa-huan-jing/"/>
      <url>/mcu/linux-he-macos-da-jian-esp32-de-vscode-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><blockquote><p>说明：第一步到第五步是安装测试ESP- IDF的步骤，和我上一篇文章同理。大家有其他方法完成也是可以的，如果之前已经测试ESP- IDF，直接去第六步<br>注意：直接去第六步的前提是ESP- IDF目录在～/esp下，工具安装在～/.espressif下，如果自己有改动这些文件夹，需改根据Vscode的ESP- IDF插件的引导设置。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>esp32开发方式有许多</p><ol><li>如在Arduino软件中Arduino框架开发方式，网上有许多教程</li><li>在platformIO中进行Arduino或者idf方式开发，platformIO封装不错</li><li>使用官方idf在linux、macos、windows开发</li></ol><p>本次记录在linux和macos搭建esp32的Vscode开发环境。</p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html#get-started-get-prerequisites">乐鑫官方文档</a></p><p><a href="https://www.bilibili.com/video/BV17p4y167uN?p=1">乐鑫ESP-IDF VS Code 插件快速操作指南(Windws)</a></p><h2 id="第一步：基础工具安装"><a href="#第一步：基础工具安装" class="headerlink" title="第一步：基础工具安装"></a>第一步：基础工具安装</h2><p>在linux或者macos中搭建esp32的环境，先要安装一些基础工具，如python等等。macos可以使用Homebrew、macports安装相关的工具以及依赖。如果部分工具已经安装过可以直接跳过。</p><ul><li>linux</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">apt</span> purge vim-common<span class="token function">apt</span> <span class="token function">install</span> <span class="token function">vim</span><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token function">wget</span> flex bison gperf python3 python3-pip <span class="token function">apt</span> <span class="token function">install</span> python3-setuptools cmake ninja-build ccache <span class="token function">apt</span> <span class="token function">install</span> libffi-dev libssl-dev dfu-util libusb-1.0-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew <span class="token function">install</span> <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二步：克隆esp-idf仓库"><a href="#第二步：克隆esp-idf仓库" class="headerlink" title="第二步：克隆esp-idf仓库"></a>第二步：克隆esp-idf仓库</h2><p>esp-idf项目是分子模块进行团队开发的SDK。因此直接克隆的仓库不能直接使用需要将子模块也克隆才能使用，我在这里卡了许久。遇到问题，使用多注意命令行的提示，对应想办法解决。</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#方案一：这是直接递归克隆乐鑫在GitHub上的esp-idf仓库，但是国内容易失败，可以试试</span><span class="token function">git</span> clone --recursive  https://github.com/espressif/esp-idf.git<span class="token comment">#方案二：先克隆esp-idf仓库，然后拉取子模块</span><span class="token function">git</span> clone https://github.com/espressif/esp-idf.git<span class="token function">git</span> submodule update --init --recursive<span class="token comment">#方案三：1.这是使用国内gitee托管克隆仓库</span><span class="token function">git</span> clone https://gitee.com/EspressifSystems/esp-idf.git<span class="token comment">#方案三：2.克隆国内gitee的工具仓库</span><span class="token function">git</span> clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<span class="token comment">#方案三：3.复制esp-gitee-tools中的submodule-update.sh到esp-idf，然后执行submodule-update.sh</span>./submodule-update.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>这一步主要思想就是将就是将官方的esp-idf仓库完整克隆下来，在这个过程中不能报错，大家也可以查看该仓库中的.gitmodules中看看有哪些子模块。在这些模块在该项目的位置在GitHub中是以超链接的方式链接的。只克隆esp-idf到本地时，这些文件夹是空的，我们只要想办法将这些空文件夹中的内容填进去就可以，各种办法都可以。</li><li>官方文档是引导我们在～/文件夹建立一个esp文件夹，然后将esp-idf放入其中，建议大家都这样做。</li></ol><h2 id="第三步：安装编译器、调试器等工具"><a href="#第三步：安装编译器、调试器等工具" class="headerlink" title="第三步：安装编译器、调试器等工具"></a>第三步：安装编译器、调试器等工具</h2><p>esp-idf包有了，需要安装esp32的编译器、调试器等等工具，其实些工具就是gcc、openocd等工具，这些工具主要是官方根据esp32修改过的定制版本。在esp-idf中，官方为我们写好下载脚本。我们只要执行脚本文件就可以安装了。esp32有esp32、esp32s2、esp32s3等等系列。我们可选系列安装或者全安装。这里我全安装</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#设置从乐鑫官方下载方式</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">IDF_GITHUB_ASSETS</span><span class="token operator">=</span><span class="token string">"dl.espressif.com/github_assets"</span><span class="token comment">#执行安装脚本</span>./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>当看到提示“You can now run：. .export.sh”,表示安装成功。</li><li>该步主要下载编译编译器、调试器等等工具，是下载工具包然后本地解压安装。如果依然失败，可以设置从乐鑫官方下载的方式，或者直接想办法下载安装包到指定目录等等方式尝试。</li></ol><h2 id="第四步：设置环境变量"><a href="#第四步：设置环境变量" class="headerlink" title="第四步：设置环境变量"></a>第四步：设置环境变量</h2><p>此时，您刚刚安装的工具尚未添加至 PATH 环境变量，无法通过“命令窗口”使用这些工具。因此，必须设置一些环境变量，这可以通过 ESP-IDF 提供的另一个脚本完成。</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#设置环境变量</span><span class="token builtin class-name">.</span> .export.sh<span class="token comment">#如果当前不在esp-idf文件夹中</span><span class="token builtin class-name">.</span> ~/esp/esp-idf/export.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>当终端关闭后设置环境变量失效。需要再次运行export.sh设置。</li><li>可以使用方法设置成打开终端自动设置环境变量，自行查找方案。</li></ol><h2 id="第五步：编译、烧录、验证"><a href="#第五步：编译、烧录、验证" class="headerlink" title="第五步：编译、烧录、验证"></a>第五步：编译、烧录、验证</h2><p>复制esp-idf/examples/get-started/下的hello_world工程或者其他工程到自己的工作目录进行编译、烧录、验证工作。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#到工作目录下</span><span class="token builtin class-name">cd</span> ~/esp/hello_world<span class="token comment">#设置目标芯片</span>idf.py set-target esp32<span class="token comment">#打开配置界面</span>idf.py menuconfig<span class="token comment">#编译</span>idf.py build<span class="token comment">#烧录</span>idf.py -p PORT <span class="token punctuation">[</span>-b BAUD<span class="token punctuation">]</span> flash<span class="token comment">#打开串口监视</span>idf.py -p PORT monitor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六步：在Vscode中安装ESP-IDF插件"><a href="#第六步：在Vscode中安装ESP-IDF插件" class="headerlink" title="第六步：在Vscode中安装ESP- IDF插件"></a>第六步：在Vscode中安装ESP- IDF插件</h2><p>这步没有什么要注意的，直接在商店安装即可</p><p><img src="/image/esp32/anzhuang.jpg" alt="安装"></p><h2 id="第七步：配置ESP-IDF插件"><a href="#第七步：配置ESP-IDF插件" class="headerlink" title="第七步：配置ESP- IDF插件"></a>第七步：配置ESP- IDF插件</h2><ol><li>查看/命令面板/Congfigure ESP-IDF，就会打开一个配置界面</li><li>配置界面有三个选项：快速、可配置、使用现有；如果没有前面1-6步的操作，可以直接使用快速按钮，会下载所有使用资源及工具，ESP-IDF会从GitHub下载。我的会失败。老老实实使用前面的方法。</li></ol><p><img src="/image/esp32/peizhi.jpg" alt="配置"></p><blockquote><p>注意：macos下安装了ESP- IDF插件后，进入配置界面没有三个配置选项，可能是插件BUG，我的隔两天再打开的时候就有配置选项了</p></blockquote><h2 id="第八步：编译、烧录、验证"><a href="#第八步：编译、烧录、验证" class="headerlink" title="第八步：编译、烧录、验证"></a>第八步：编译、烧录、验证</h2><p>和第五步一样，我们复制一个实例工程，或者打开插件的实例工程编译、下载、测试即可。<br><img src="/image/esp32/shili.jpg" alt="实例"><br><img src="/image/esp32/anjian.jpg" alt="按键"></p><blockquote><p>注意：linux编译通过，但是烧录会失败，会弹出提示，访问USB权限不够，原因是openocd访问USB失败，根据linux下Vcsode的提示复制60-openocd.rules到/etc/udev/rules.d/60-openocd.rules，依然不可行，我们在该文件中添加一行：KERNEL==”ttyUSB[0-9]*”, MODE=”0666”  然后重新插入USB就可以了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内linux和macos搭建esp32的开发环境</title>
      <link href="/mcu/guo-nei-linux-he-macos-da-jian-esp32-de-kai-fa-huan-jing/"/>
      <url>/mcu/guo-nei-linux-he-macos-da-jian-esp32-de-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>esp32开发方式有许多</p><ol><li>如在Arduino软件中Arduino框架开发方式，网上有许多教程</li><li>在platformIO中进行Arduino或者idf方式开发，platformIO封装不错</li><li>使用官方idf在linux、macos、windows开发</li></ol><p>最近想了解一下官方SDK的开发方式，在搭建esp32的环境中遇到许多问题。</p><p>该搭建方案和官方文档配合查看，部分细节该文档未列出</p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html#get-started-get-prerequisites">乐鑫官方文档</a></p><h2 id="第一步：基础工具安装"><a href="#第一步：基础工具安装" class="headerlink" title="第一步：基础工具安装"></a>第一步：基础工具安装</h2><p>在linux或者macos中搭建esp32的环境，先要安装一些基础工具，如python等等。macos可以使用Homebrew、macports安装相关的工具以及依赖。如果部分工具已经安装过可以直接跳过。</p><ul><li>linux</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">apt</span> purge vim-common<span class="token function">apt</span> <span class="token function">install</span> <span class="token function">vim</span><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token function">wget</span> flex bison gperf python3 python3-pip <span class="token function">apt</span> <span class="token function">install</span> python3-setuptools cmake ninja-build ccache <span class="token function">apt</span> <span class="token function">install</span> libffi-dev libssl-dev dfu-util libusb-1.0-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew <span class="token function">install</span> <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二步：克隆esp-idf仓库"><a href="#第二步：克隆esp-idf仓库" class="headerlink" title="第二步：克隆esp-idf仓库"></a>第二步：克隆esp-idf仓库</h2><p>esp-idf项目是分子模块进行团队开发的SDK。因此直接克隆的仓库不能直接使用需要将子模块也克隆才能使用，我在这里卡了许久。遇到问题，使用多注意命令行的提示，对应想办法解决。</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#方案一：这是直接递归克隆乐鑫在GitHub上的esp-idf仓库，但是国内容易失败，可以试试</span><span class="token function">git</span> clone --recursive  https://github.com/espressif/esp-idf.git<span class="token comment">#方案二：先克隆esp-idf仓库，然后拉取子模块</span><span class="token function">git</span> clone https://github.com/espressif/esp-idf.git<span class="token function">git</span> submodule update --init --recursive<span class="token comment">#方案三：1.这是使用国内gitee托管克隆仓库</span><span class="token function">git</span> clone https://gitee.com/EspressifSystems/esp-idf.git<span class="token comment">#方案三：2.克隆国内gitee的工具仓库</span><span class="token function">git</span> clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<span class="token comment">#方案三：3.复制esp-gitee-tools中的submodule-update.sh到esp-idf，然后执行submodule-update.sh</span>./submodule-update.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>这一步主要思想就是将就是将官方的esp-idf仓库完整克隆下来，在这个过程中不能报错，大家也可以查看该仓库中的.gitmodules中看看有哪些子模块。在这些模块在该项目的位置在GitHub中是以超链接的方式链接的。只克隆esp-idf到本地时，这些文件夹是空的，我们只要想办法将这些空文件夹中的内容填进去就可以，各种办法都可以。</li><li>官方文档是引导我们在～/文件夹建立一个esp文件夹，然后将esp-idf放入其中，建议大家都这样做。</li></ol><h2 id="第三步：安装编译器、调试器等工具"><a href="#第三步：安装编译器、调试器等工具" class="headerlink" title="第三步：安装编译器、调试器等工具"></a>第三步：安装编译器、调试器等工具</h2><p>esp-idf包有了，需要安装esp32的编译器、调试器等等工具，其实些工具就是gcc、openocd等工具，这些工具主要是官方根据esp32修改过的定制版本。在esp-idf中，官方为我们写好下载脚本。我们只要执行脚本文件就可以安装了。esp32有esp32、esp32s2、esp32s3等等系列。我们可选系列安装或者全安装。这里我全安装</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#设置从乐鑫官方下载方式</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">IDF_GITHUB_ASSETS</span><span class="token operator">=</span><span class="token string">"dl.espressif.com/github_assets"</span><span class="token comment">#执行安装脚本</span>./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>当看到提示“You can now run：. .export.sh”,表示安装成功。</li><li>该步主要下载编译编译器、调试器等等工具，是下载工具包然后本地解压安装。如果依然失败，可以设置从乐鑫官方下载的方式，或者直接想办法下载安装包到指定目录等等方式尝试。</li></ol><h2 id="第四步：设置环境变量"><a href="#第四步：设置环境变量" class="headerlink" title="第四步：设置环境变量"></a>第四步：设置环境变量</h2><p>此时，您刚刚安装的工具尚未添加至 PATH 环境变量，无法通过“命令窗口”使用这些工具。因此，必须设置一些环境变量，这可以通过 ESP-IDF 提供的另一个脚本完成。</p><ul><li>linux、macos</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#设置环境变量</span><span class="token builtin class-name">.</span> .export.sh<span class="token comment">#如果当前不在esp-idf文件夹中</span><span class="token builtin class-name">.</span> ~/esp/esp-idf/export.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><ol><li>当终端关闭后设置环境变量失效。需要再次运行export.sh设置。</li><li>可以使用方法设置成打开终端自动设置环境变量，自行查找方案。</li></ol><h2 id="第五步：编译、烧录、验证"><a href="#第五步：编译、烧录、验证" class="headerlink" title="第五步：编译、烧录、验证"></a>第五步：编译、烧录、验证</h2><p>复制esp-idf/examples/get-started/下的hello_world工程或者其他工程到自己的工作目录进行编译、烧录、验证工作。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#到工作目录下</span><span class="token builtin class-name">cd</span> ~/esp/hello_world<span class="token comment">#设置目标芯片</span>idf.py set-target esp32<span class="token comment">#打开配置界面</span>idf.py menuconfig<span class="token comment">#编译</span>idf.py build<span class="token comment">#烧录</span>idf.py -p PORT <span class="token punctuation">[</span>-b BAUD<span class="token punctuation">]</span> flash<span class="token comment">#打开串口监视</span>idf.py -p PORT monitor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本命令</title>
      <link href="/tools/git-ji-ben-ming-ling/"/>
      <url>/tools/git-ji-ben-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置操作"><a href="#配置操作" class="headerlink" title="配置操作"></a>配置操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 显示当前的Git配置</span>$ <span class="token function">git</span> config --list<span class="token comment"># 编辑Git配置文件</span>$ <span class="token function">git</span> config -e <span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token comment"># 设置提交代码时的用户信息</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.name <span class="token string">"[name]"</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.email <span class="token string">"[email address]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> <span class="token function">add</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> <span class="token function">add</span> <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment"># 添加每个变化前，都会要求确认</span><span class="token comment"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> <span class="token function">add</span> -p<span class="token comment"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment"># 使用一次新的commit，替代上一次提交</span><span class="token comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment"># 新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@&#123;0 day ago&#125;"</span><span class="token comment"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程同步操作"><a href="#远程同步操作" class="headerlink" title="远程同步操作"></a>远程同步操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote <span class="token function">add</span> <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token builtin class-name">.</span><span class="token comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment"># 新建一个commit，用来撤销指定commit</span><span class="token comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>暂时将未提交的变化移除，稍后再移入$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="发布操作"><a href="#发布操作" class="headerlink" title="发布操作"></a>发布操作</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 生成一个可供发布的压缩包</span>$ <span class="token function">git</span> archive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Macos和Linux的Vscode中模拟LGVL</title>
      <link href="/gui/zai-macos-he-linux-de-vscode-zhong-mo-ni-lgvl/"/>
      <url>/gui/zai-macos-he-linux-de-vscode-zhong-mo-ni-lgvl/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LGVL是一个开源的嵌入式GUI，可以方面进行嵌入式的图形界面开发。</p><h2 id="Linux-Macos在vscode中模拟LGVL步骤"><a href="#Linux-Macos在vscode中模拟LGVL步骤" class="headerlink" title="Linux/Macos在vscode中模拟LGVL步骤"></a>Linux/Macos在vscode中模拟LGVL步骤</h2><ol><li>确保PC安装了gcc、make、gdb三个软件，以及Vscode</li></ol><ul><li>linux如没有gcc、make、gdb使用apt工具直接安装</li><li>在macos下安装了xcode的话默认已经有make和gcc，gcc是clang链接出来的，可以正常使用</li><li>macos使用gdb使用brew工具安装</li><li>由于gdb在macos中安装，需要权限较高，可以使用自带的lldb代替</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew <span class="token function">install</span> gdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>在官方Github中克隆或者下载<a href="https://github.com/lvgl/lv_sim_vscode_sdl">lv_sim_vscode_sdl</a>包</li></ol><p><img src="/image/lvgl/lvgl77.jpeg" alt="lv_sim_vscode_sdl"><br>3. 由于lv_sim_vscode_sdl需要的lv_drivers、lv_examples、lvgl是链接的方式；在lv_sim_vscode_sdl没有实际内容，因此，我们克隆或者下载<a href="https://github.com/lvgl/lv_drivers/tree/f14e31612409fc9216892cb58eb9d851667f8a11">lv_drivers</a>、<a href="https://github.com/lvgl/lv_demos/tree/4d6f215c2bfd534eda744db512ea30685e5faf75">lv_examples</a>、<a href="https://github.com/lvgl/lvgl/tree/c597d257984e2cd3a1c883dc97a26d4512b5e60a">lvgl</a></p><p><img src="/image/lvgl/lvgl78.jpeg" alt="lv_drivers"></p><p><img src="/image/lvgl/lvgl79.jpeg" alt="lv_examples"></p><p><img src="/image/lvgl/lvgl80.jpeg" alt="lvgl"></p><ol start="4"><li>在Vscode中打开文件夹lv_sim_vscode_sdl</li><li>如果是在macos使用lldb工具则在launch.json修改”MIMode”为”lldb”</li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"g++ build and debug active file"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>        <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>        <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/build/bin/demo"</span><span class="token punctuation">,</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>        <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"lldb"</span><span class="token punctuation">,</span>        <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Enable pretty-printing for gdb"</span><span class="token punctuation">,</span>            <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>            <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"Build"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>按键F5则可以预览模拟器，模拟为官方实例程序，如需模拟自己的程序，根据官方手册替换为自己的代码即可模拟。</li></ol>]]></content>
      
      
      <categories>
          
          <category> gui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lgvl </tag>
            
            <tag> gui </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用说明</title>
      <link href="/website/hexo-shi-yong-shuo-ming/"/>
      <url>/website/hexo-shi-yong-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ol><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<ul><li>Windows：通过 nvs（推荐）或者 nvm 安装。</li><li>Mac：使用 Homebrew 或 MacPorts 安装。</li><li>Linux（DEB/RPM-based）：从 NodeSource 安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导。</li></ul></li><li>Git<ul><li>Windows：下载并安装 git.</li><li>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</li><li>Linux (Ubuntu, Debian)：sudo apt-get install git-core</li><li>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</li></ul></li></ol><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><ol><li>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>新建完成后，指定文件夹的目录如下：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span>├── _config.yml├── package.json├── scaffolds├── <span class="token builtin class-name">source</span><span class="token operator">|</span>   ├── _drafts<span class="token operator">|</span>   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>本地预览</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>推到远端</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;&amp;</span> hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推到远端前提配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> 仓库地址  <span class="token key atrule">branch</span><span class="token punctuation">:</span> 仓库分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> website </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github做图床</title>
      <link href="/website/github-zuo-tu-chuang/"/>
      <url>/website/github-zuo-tu-chuang/</url>
      
        <content type="html"><![CDATA[<h2 id="github建立仓库"><a href="#github建立仓库" class="headerlink" title="github建立仓库"></a>github建立仓库</h2><ol><li>新建仓库（仓库一定公开）</li></ol><h2 id="上传图片到该仓库"><a href="#上传图片到该仓库" class="headerlink" title="上传图片到该仓库"></a>上传图片到该仓库</h2><ol><li>上传的图片可以存储到根目录，也可以建立文件，但访问的时候要注意即可</li></ol><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ol><li>使用开源jsdelivr的cdn进行访问，可以加快速度。</li></ol><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;&#123;github用户名&#125;&#x2F;&#123;github仓库名&#125;@&#123;仓库分支名&#125;&#x2F;文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：如果仓库还有文件夹，文件名中也好包含文件夹路径</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> website </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试单片机的link-debuger</title>
      <link href="/project/diao-shi-dan-pian-ji-de-link-debuger/"/>
      <url>/project/diao-shi-dan-pian-ji-de-link-debuger/</url>
      
        <content type="html"><![CDATA[<p>仓库地址：<a href="https://github.com/fzxhub/link_debuger">GitHub</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本项目是一个link debuger，用于调试带有JTAG、SWD接口的微控制器。由于SWD接口的优势，以及本项目宗旨是做一个美观、小巧、功能全的调试器，因此查阅了许多开源电路、开源固件。最终做了该PCB。由上下两层PCB通过铜柱连接在一起。铜柱复用为上下板供电线路。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>小巧、多功能</p></li><li><p>插针隐藏设计、方便携带</p></li><li><p>支持Jlink、STlink、DAPlink</p></li><li><p>支持RS485调试</p></li><li><p>支持ESP32等IC的自动下载（RTS、DTR信号预留）</p></li><li><p>使用Typec接口的对称性改成SWD、UART信号接口</p></li><li><p>采用底板顶板贴合设计、铜柱复用电源连接底板顶板</p></li></ul><h2 id="实物展示"><a href="#实物展示" class="headerlink" title="实物展示"></a>实物展示</h2><p><img src="/image/link/links2.jpg" alt="link实物"></p><p><img src="/image/link/links1.jpg" alt="link实物"></p><p><img src="/image/link/links3.jpg" alt="link实物"></p><h2 id="底板3D图"><a href="#底板3D图" class="headerlink" title="底板3D图"></a>底板3D图</h2><p><img src="/image/link/link4.png" alt="底板3D图"></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li><p>debuger（jlink、stlink、daplink任意中的一种）</p><ul><li><p>SWD接口下载和调试功能</p></li><li><p>link虚拟的串口功能（需要jlink、stlink、daplink固件支持）</p></li><li><p>link支持拖拽下载（需要jlink、stlink、daplink固件支持）</p></li></ul></li><li><p>USB转UART（CP2102虚拟的串口）</p></li><li><p>USB转RS485（RS485由CP2102的UART电平转化，同一时刻只使用一种，EN接通使用RS485，不接使用UART）</p></li><li><p>USB HUB（可以再接入其他1个USB设备，TYPEC接口）</p></li><li><p>信号线交叉硬件设计</p></li></ol><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><ul><li><p>link功能表示可是使用jlink、stlink、daplink任意一种固件，烧录入不同的link固件，该设备就是可以实现变身。</p></li><li><p>USB转串口功能，因为三种固件都支持虚拟UART功能，因此都可以使用USB转UART（TTL），下载、调试、UART调试集一身。</p></li><li><p>除了固件虚拟的UART，再接入一个CP2102虚拟一个串口，该串口主要引出RTS、DTR信号，在目标板上合理设计可以自动下载ESP32、STM32串口下载。</p></li><li><p>还将CP2102虚拟的UART（TTL）进行电平转换后得到RS485接口，用于RS485调试</p></li><li><p>在输入USB接口之后绘制了一个USB HUB芯片，芯片是支持一拖四USB HUB，速率达到USB2.0。可通过电阻选择USB HUB是否使用。设计成可选择，主要防止USB HUB的不稳定造成link debugger的不稳定，如USB HUB不稳定或者不使用，可进行硬件上的切换。切换方式通过丝印在背面。</p></li><li><p>信号线交叉设计主要用于在电路设计时大意将例如UART的RX、TX接错时可切换debuger的电阻即可。切换方式通过丝印在背面。</p></li><li><p>本设计接口使用了typec USB接口定义了SWD接口、UART接口。在设计你的原型电路时，可以使用typec USB来设计SWD、UART接口后，通过typec USB线连接PC、link debuger、原型电路即可开始下载与调试。</p></li><li><p>该设备输出共四个typec USB：</p><ul><li><p>typec USB1：SWD、UART接口</p></li><li><p>typec USB2：固件虚拟的UART接口 </p></li><li><p>typec USB3：CP2102虚拟的UART接口，带DTR、RTS信号</p></li><li><p>typec USB4：USB HUB接口</p></li></ul></li></ul><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a><strong>接口定义</strong></h3><p><img src="/image/link/link3.png" alt="接口定义图"></p><h2 id="支持固件类型"><a href="#支持固件类型" class="headerlink" title="支持固件类型"></a>支持固件类型</h2><ol><li>jlink</li><li>stlink</li><li>daplink</li></ol><h2 id="支持接口与定义"><a href="#支持接口与定义" class="headerlink" title="支持接口与定义"></a>支持接口与定义</h2><p>说明：个人觉得嵌入式开发调试接口20PIN的牛角座端子太大，不适合在开发板或者项目电路板上使用，直接使用插针的方式在电路板使用，当迁移电路板后需要再次每根杜邦线连接，累~，在USB接口定义有可以直接使用的线和接口，因此我想使用USB线来做我们SWD、UART接口的使用。</p><p>我在之后的电路板、自绘开发上直接使用TYPEC接口母座来连接SWD、UART接口后，使用TYPEC线连接link_debuger和电路板即可开始使用。因此有了以下将USB接口信号改成SWD、UART接口的定义。<br>利用TYPEC正反插时的对称性。</p><ol><li><p>typec USB类型的SWD&amp;UART支持接口：</p><ul><li>VCC、SCK、SWD、SWO、RST、TX、RX、GND</li><li>接口对应<table><thead><tr><th align="center">TYPEC母座信号定义</th><th align="center">自定义SWD、UART信号</th></tr></thead><tbody><tr><td align="center">VBUS</td><td align="center">VCC</td></tr><tr><td align="center">D+(DP)</td><td align="center">SCK（可与SWD交换）</td></tr><tr><td align="center">D-(DN)</td><td align="center">SWD（可与SCK交换）</td></tr><tr><td align="center">TX1-&amp;TX2-</td><td align="center">RST</td></tr><tr><td align="center">RX1-&amp;RX2-</td><td align="center">SWO</td></tr><tr><td align="center">TX1+&amp;TX2+</td><td align="center">TX（可与RX交换）</td></tr><tr><td align="center">RX1+&amp;RX2+</td><td align="center">RX（可与TX交换）</td></tr><tr><td align="center">GND</td><td align="center">GND</td></tr></tbody></table></li></ul></li><li><p>typec USB类型的UART</p><ul><li>VCC、TX、RX、GND</li><li>接口对应说明<table><thead><tr><th align="center">TYPEC母座信号定义</th><th align="center">自定义SWD、UART信号</th></tr></thead><tbody><tr><td align="center">VBUS</td><td align="center">VCC</td></tr><tr><td align="center">D-(DN)</td><td align="center">TX（可与RX交换）</td></tr><tr><td align="center">D+(DP)</td><td align="center">RX（可与TX交换）</td></tr><tr><td align="center">GND</td><td align="center">GND</td></tr></tbody></table></li></ul></li><li><p>typec USB类型的UART，带DTR、RTS信号</p><ul><li>VCC、TX、RX、RTS、DTR、GND</li><li>接口对应说明<table><thead><tr><th align="center">TYPEC母座信号定义</th><th align="center">自定义SWD、UART信号</th></tr></thead><tbody><tr><td align="center">VBUS</td><td align="center">VCC</td></tr><tr><td align="center">D-(DN)</td><td align="center">RX（可与TX交换）</td></tr><tr><td align="center">D+(DP)</td><td align="center">TX（可与RX交换）</td></tr><tr><td align="center">TX1+&amp;TX2+</td><td align="center">DTR</td></tr><tr><td align="center">RX1+&amp;RX2+</td><td align="center">RTS</td></tr><tr><td align="center">GND</td><td align="center">GND</td></tr></tbody></table></li></ul></li><li><p>typec USB类型的USB HUB2.0</p><ul><li>5.0V、D+、D-、GND</li></ul></li><li><p>2.54间距8PIN的SWD&amp;UART接口</p><ul><li>VCC、SCK、SWD、SWO、RST、TX、RX、GND</li></ul></li><li><p>2.54间距6PIN的UART接口</p><ul><li>VCC、TX、RX、RTS、DTR、GND</li></ul></li><li><p>2.54间距2PIN的RS485接口（EN接通使用RS485，不接使用UART）</p><ul><li>A、B</li></ul></li><li><p>2.54间距6PIN的供电</p><ul><li>3.3V、3.3V、5.0V、5.0V、GND、GND</li></ul></li><li><p>20PIN的JTAG接口（只支持SWD，默认不焊接，焊接20PIN贴片插针或者牛角座即可使用）</p></li></ol><p><img src="/image/link/link5.png" alt="顶部3D图"></p><h2 id="固件切换"><a href="#固件切换" class="headerlink" title="固件切换"></a>固件切换</h2><ol><li><p>使用自己的STLINK与link_debuger的5.0V、SWD、SCK、GND连接。</p></li><li><p>打开STM32 ST-LINK Utility</p></li><li><p>连接设备<br><img src="/image/link/prog1.png" alt="连接设备"></p></li><li><p>打开文件<br><img src="/image/link/prog2.png" alt="打开文件"></p></li><li><p>选择固件（DAP选择bootloader）<br><img src="/image/link/prog3.png" alt="选择固件"></p></li><li><p>开始编程<br><img src="/image/link/prog4.png" alt="开始编程"></p></li><li><p>点击start、等待进度条完成后即可使用<br><img src="/image/link/prog5.png" alt="点击start"><br><img src="/image/link/prog6.png" alt="等待进度条"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> link </tag>
            
            <tag> debuger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客主题hexo-theme-materyde使用</title>
      <link href="/website/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-shi-yong/"/>
      <url>/website/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://github.com/blinkfox">blinkfox</a><br><a href="https://blinkfox.github.io/">演示示例</a> | QQ交流群:<code>926552981</code></p><blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># default false</span>  custom_css<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"/medias/music/cover2.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">showTitle</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span> <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'list'</span> <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span> <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> <span class="token comment"># 列表最大高度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-1.png" alt="首页"></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h2><ul><li>v1.0.0<ul><li>新增了所有基础功能；</li></ul></li><li>v1.0.1<ul><li>调整 <code>css</code>、<code>js</code> 的文件请求路径在主题的<code>_config.yml</code>中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 <code>TOC</code> 功能，并新增为某篇文章关闭 <code>TOC</code> 的 <code>Front-matter</code> 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li><code>IOS</code>下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li><li>v1.0.2<ul><li>升级了 <a href="https://materializecss.com/">Materialize</a> 框架版本为<code>1.0.0</code>，重构和修改了升级过程中的部分文件或问题；</li><li>新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中；</li><li>修复首页第一个按钮是中文的问题</li><li>修复了 iPhone 上点击搜索输入获取焦点的问题；</li><li>修复了 iPhone 上输入框获取焦点后页面放大的问题；</li><li>修复一些文章或 UI 显示问题；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> website </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
